diff -Naur linux-2.6.8.1/Makefile linux-2.6.8.1-m68k-20040817/Makefile
--- linux-2.6.8.1/Makefile	2004-08-14 20:55:35.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/Makefile	2004-08-16 02:12:43.000000000 +1000
@@ -172,7 +172,7 @@
 # Default value for CROSS_COMPILE is not to prefix executables
 # Note: Some architectures assign CROSS_COMPILE in their arch/*/Makefile
 
-ARCH		?= $(SUBARCH)
+ARCH		?= m68k
 CROSS_COMPILE	?=
 
 # Architecture as present in compile.h
diff -Naur linux-2.6.8.1/arch/m68k/Kconfig linux-2.6.8.1-m68k-20040817/arch/m68k/Kconfig
--- linux-2.6.8.1/arch/m68k/Kconfig	2004-08-14 20:55:34.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/arch/m68k/Kconfig	2004-07-12 03:44:05.000000000 +1000
@@ -187,17 +187,19 @@
 	  drivers for SCSI, Ethernet and serial ports later on.
 
 config HP300
-	bool "HP9000/300 support"
+	bool "HP9000/300 and HP9000/400 support"
 	depends on !MMU_SUN3
 	help
-	  This option enables support for the HP9000/300 series of
-	  workstations. Support for these machines is still very experimental.
-	  If you plan to try to use the kernel on such a machine say Y here.
+	  This option enables support for the HP9000/300 and HP9000/400 series
+	  of workstations. Support for these machines is still somewhat
+	  experimental. If you plan to try to use the kernel on such a machine
+	  say Y here.
 	  Everybody else says N.
 
 config DIO
 	bool "DIO bus support"
 	depends on HP300
+	default y
 	help
 	  Say Y here to enable support for the "DIO" expansion bus used in
 	  HP300 machines. If you are using such a system you almost certainly
@@ -586,11 +588,18 @@
 
 config HPDCA
 	tristate "HP DCA serial support"
-	depends on DIO
+	depends on DIO && SERIAL_8250
 	help
 	  If you want to use the internal "DCA" serial ports on an HP300
 	  machine, say Y here.
 
+config HPAPCI
+	tristate "HP APCI serial support"
+	depends on HP300 && SERIAL_8250 && EXPERIMENTAL
+	help
+	  If you want to use the internal "APCI" serial ports on an HP400
+	  machine, say Y here.
+
 config MVME147_SCC
 	bool "SCC support for MVME147 serial ports"
 	depends on MVME147
@@ -627,7 +636,7 @@
 
 config SERIAL_CONSOLE
 	bool "Support for serial port console"
-	depends on (AMIGA || ATARI || MAC || HP300 || SUN3 || SUN3X || VME || APOLLO) && (ATARI_MFPSER=y || ATARI_SCC=y || ATARI_MIDI=y || MAC_SCC=y || AMIGA_BUILTIN_SERIAL=y || GVPIOEXT=y || MULTIFACE_III_TTY=y || HPDCA=y || SERIAL=y || MVME147_SCC || SERIAL167 || MVME162_SCC || BVME6000_SCC || DN_SERIAL)
+	depends on (AMIGA || ATARI || MAC || SUN3 || SUN3X || VME || APOLLO) && (ATARI_MFPSER=y || ATARI_SCC=y || ATARI_MIDI=y || MAC_SCC=y || AMIGA_BUILTIN_SERIAL=y || GVPIOEXT=y || MULTIFACE_III_TTY=y || SERIAL=y || MVME147_SCC || SERIAL167 || MVME162_SCC || BVME6000_SCC || DN_SERIAL)
 	---help---
 	  If you say Y here, it will be possible to use a serial port as the
 	  system console (the system console is the device which receives all
diff -Naur linux-2.6.8.1/arch/m68k/hp300/config.c linux-2.6.8.1-m68k-20040817/arch/m68k/hp300/config.c
--- linux-2.6.8.1/arch/m68k/hp300/config.c	2004-08-14 20:54:48.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/arch/m68k/hp300/config.c	2004-07-10 06:52:29.000000000 +1000
@@ -7,56 +7,272 @@
  *  called by setup.c.
  */
 
-#include <linux/config.h>
-#include <linux/types.h>
-#include <linux/mm.h>
-#include <linux/kd.h>
-#include <linux/tty.h>
-#include <linux/console.h>
-#include <linux/interrupt.h>
+#include <linux/module.h>
 #include <linux/init.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/console.h>
+
+#include <asm/bootinfo.h>
 #include <asm/machdep.h>
 #include <asm/blinken.h>
-#include <asm/hwtest.h>                           /* hwreg_present() */
+#include <asm/io.h>                               /* readb() and writeb() */
+#include <asm/hp300hw.h>
+#include <asm/rtc.h>
 
 #include "ints.h"
 #include "time.h"
 
+unsigned long hp300_model;
+unsigned long hp300_uart_scode = -1;
+unsigned char ledstate;
+
+static char s_hp330[] __initdata = "330";
+static char s_hp340[] __initdata = "340";
+static char s_hp345[] __initdata = "345";
+static char s_hp360[] __initdata = "360";
+static char s_hp370[] __initdata = "370";
+static char s_hp375[] __initdata = "375";
+static char s_hp380[] __initdata = "380";
+static char s_hp385[] __initdata = "385";
+static char s_hp400[] __initdata = "400";
+static char s_hp425t[] __initdata = "425t";
+static char s_hp425s[] __initdata = "425s";
+static char s_hp425e[] __initdata = "425e";
+static char s_hp433t[] __initdata = "433t";
+static char s_hp433s[] __initdata = "433s";
+static char *hp300_models[] __initdata = {
+	[HP_320]	= NULL,
+	[HP_330]	= s_hp330,
+	[HP_340]	= s_hp340,
+	[HP_345]	= s_hp345,
+	[HP_350]	= NULL,
+	[HP_360]	= s_hp360,
+	[HP_370]	= s_hp370,
+	[HP_375]	= s_hp375,
+	[HP_380]	= s_hp380,
+	[HP_385]	= s_hp385,
+	[HP_400]	= s_hp400,
+	[HP_425T]	= s_hp425t,
+	[HP_425S]	= s_hp425s,
+	[HP_425E]	= s_hp425e,
+	[HP_433T]	= s_hp433t,
+	[HP_433S]	= s_hp433s,
+};
+
+static char hp300_model_name[13] = "HP9000/";
+
 extern void hp300_reset(void);
 extern irqreturn_t (*hp300_default_handler[])(int, void *, struct pt_regs *);
 extern int show_hp300_interrupts(struct seq_file *, void *);
+#ifdef CONFIG_SERIAL_8250_CONSOLE
+extern int hp300_setup_serial_console(void) __init;
+#endif
+
+int __init hp300_parse_bootinfo(const struct bi_record *record)
+{
+	int unknown = 0;
+	const unsigned long *data = record->data;
+
+	switch (record->tag) {
+	case BI_HP300_MODEL:
+		hp300_model = *data;
+		break;
+
+	case BI_HP300_UART_SCODE:
+		hp300_uart_scode = *data;
+		break;
+
+	case BI_HP300_UART_ADDR:
+		/* serial port address: ignored here */
+		break;
+
+        default:
+		unknown = 1;
+	}
+
+	return unknown;
+}
 
 #ifdef CONFIG_HEARTBEAT
 static void hp300_pulse(int x)
 {
-   if (x)
-      blinken_leds(0xfe);
-   else
-      blinken_leds(0xff);
+	if (x)
+		blinken_leds(0x10, 0);
+	else
+		blinken_leds(0, 0x10);
 }
 #endif
 
 static void hp300_get_model(char *model)
 {
-  strcpy(model, "HP9000/300");
+	strcpy(model, hp300_model_name);
+}
+
+#define RTCBASE			0xf0420000
+#define RTC_DATA		0x1
+#define RTC_CMD			0x3
+
+#define	RTC_BUSY		0x02
+#define	RTC_DATA_RDY		0x01
+
+#define rtc_busy()		(in_8(RTCBASE + RTC_CMD) & RTC_BUSY)
+#define rtc_data_available()	(in_8(RTCBASE + RTC_CMD) & RTC_DATA_RDY)
+#define rtc_status()		(in_8(RTCBASE + RTC_CMD))
+#define rtc_command(x)		out_8(RTCBASE + RTC_CMD, (x))
+#define rtc_read_data()		(in_8(RTCBASE + RTC_DATA))
+#define rtc_write_data(x)	out_8(RTCBASE + RTC_DATA, (x))
+
+#define RTC_SETREG	0xe0
+#define RTC_WRITEREG	0xc2
+#define RTC_READREG	0xc3
+
+#define RTC_REG_SEC2	0
+#define RTC_REG_SEC1	1
+#define RTC_REG_MIN2	2
+#define RTC_REG_MIN1	3
+#define RTC_REG_HOUR2	4
+#define RTC_REG_HOUR1	5
+#define RTC_REG_WDAY	6
+#define RTC_REG_DAY2	7
+#define RTC_REG_DAY1	8
+#define RTC_REG_MON2	9
+#define RTC_REG_MON1	10
+#define RTC_REG_YEAR2	11
+#define RTC_REG_YEAR1	12
+
+#define RTC_HOUR1_24HMODE 0x8
+
+#define RTC_STAT_MASK	0xf0
+#define RTC_STAT_RDY	0x40
+
+static inline unsigned char hp300_rtc_read(unsigned char reg)
+{
+	unsigned char s, ret;
+	unsigned long flags;
+
+	local_irq_save(flags);
+
+	while (rtc_busy());
+	rtc_command(RTC_SETREG);
+	while (rtc_busy());
+	rtc_write_data(reg);
+	while (rtc_busy());
+	rtc_command(RTC_READREG);
+
+	do {
+		while (!rtc_data_available());
+		s = rtc_status();
+		ret = rtc_read_data();
+	} while ((s & RTC_STAT_MASK) != RTC_STAT_RDY);
+
+	local_irq_restore(flags);
+
+	return ret;
+}
+
+static inline unsigned char hp300_rtc_write(unsigned char reg,
+					    unsigned char val)
+{
+	unsigned char s, ret;
+	unsigned long flags;
+
+	local_irq_save(flags);
+
+	while (rtc_busy());
+	rtc_command(RTC_SETREG);
+	while (rtc_busy());
+	rtc_write_data((val << 4) | reg);
+	while (rtc_busy());
+	rtc_command(RTC_WRITEREG);
+	while (rtc_busy());
+	rtc_command(RTC_READREG);
+
+	do {
+		while (!rtc_data_available());
+		s = rtc_status();
+		ret = rtc_read_data();
+	} while ((s & RTC_STAT_MASK) != RTC_STAT_RDY);
+
+	local_irq_restore(flags);
+
+	return ret;
+}
+
+static int hp300_hwclk(int op, struct rtc_time *t)
+{
+	if (!op) { /* read */
+		t->tm_sec  = hp300_rtc_read(RTC_REG_SEC1) * 10 +
+			hp300_rtc_read(RTC_REG_SEC2);
+		t->tm_min  = hp300_rtc_read(RTC_REG_MIN1) * 10 +
+			hp300_rtc_read(RTC_REG_MIN2);
+		t->tm_hour = (hp300_rtc_read(RTC_REG_HOUR1) & 3) * 10 +
+			hp300_rtc_read(RTC_REG_HOUR2);
+		t->tm_wday = -1;
+		t->tm_mday = hp300_rtc_read(RTC_REG_DAY1) * 10 +
+			hp300_rtc_read(RTC_REG_DAY2);
+		t->tm_mon  = hp300_rtc_read(RTC_REG_MON1) * 10 +
+			hp300_rtc_read(RTC_REG_MON2) - 1;
+		t->tm_year = hp300_rtc_read(RTC_REG_YEAR1) * 10 +
+			hp300_rtc_read(RTC_REG_YEAR2);
+		if (t->tm_year <= 69)
+			t->tm_year += 100;
+	} else {
+		hp300_rtc_write(RTC_REG_SEC1, t->tm_sec / 10);
+		hp300_rtc_write(RTC_REG_SEC2, t->tm_sec % 10);
+		hp300_rtc_write(RTC_REG_MIN1, t->tm_min / 10);
+		hp300_rtc_write(RTC_REG_MIN2, t->tm_min % 10);
+		hp300_rtc_write(RTC_REG_HOUR1,
+				((t->tm_hour / 10) & 3) | RTC_HOUR1_24HMODE);
+		hp300_rtc_write(RTC_REG_HOUR2, t->tm_hour % 10);
+		hp300_rtc_write(RTC_REG_DAY1, t->tm_mday / 10);
+		hp300_rtc_write(RTC_REG_DAY2, t->tm_mday % 10);
+		hp300_rtc_write(RTC_REG_MON1, (t->tm_mon + 1) / 10);
+		hp300_rtc_write(RTC_REG_MON2, (t->tm_mon + 1) % 10);
+		if (t->tm_year >= 100)
+			t->tm_year -= 100;
+		hp300_rtc_write(RTC_REG_YEAR1, t->tm_year / 10);
+		hp300_rtc_write(RTC_REG_YEAR2, t->tm_year % 10);
+	}
+
+	return 0;
+}
+
+static unsigned int hp300_get_ss(void)
+{
+	return hp300_rtc_read(RTC_REG_SEC1) * 10 +
+		hp300_rtc_read(RTC_REG_SEC2);
 }
 
 void __init config_hp300(void)
 {
-  mach_sched_init      = hp300_sched_init;
-  mach_init_IRQ        = hp300_init_IRQ;
-  mach_request_irq     = hp300_request_irq;
-  mach_free_irq        = hp300_free_irq;
-  mach_get_model       = hp300_get_model;
-  mach_get_irq_list    = show_hp300_interrupts;
-  mach_gettimeoffset   = hp300_gettimeoffset;
-  mach_default_handler = &hp300_default_handler;
-  mach_reset           = hp300_reset;
+	mach_sched_init      = hp300_sched_init;
+	mach_init_IRQ        = hp300_init_IRQ;
+	mach_request_irq     = hp300_request_irq;
+	mach_free_irq        = hp300_free_irq;
+	mach_get_model       = hp300_get_model;
+	mach_get_irq_list    = show_hp300_interrupts;
+	mach_gettimeoffset   = hp300_gettimeoffset;
+	mach_default_handler = &hp300_default_handler;
+	mach_hwclk	     = hp300_hwclk;
+	mach_get_ss	     = hp300_get_ss;
+	mach_reset           = hp300_reset;
 #ifdef CONFIG_HEARTBEAT
-  mach_heartbeat       = hp300_pulse;
+	mach_heartbeat       = hp300_pulse;
 #endif
 #ifdef CONFIG_DUMMY_CONSOLE
-  conswitchp	       = &dummy_con;
+	conswitchp	     = &dummy_con;
+#endif
+	mach_max_dma_address = 0xffffffff;
+
+	if (hp300_model >= HP_330 && hp300_model <= HP_433S && hp300_model != HP_350) {
+		printk(KERN_INFO "Detected HP9000 model %s\n", hp300_models[hp300_model-HP_320]);
+		strcat(hp300_model_name, hp300_models[hp300_model-HP_320]);
+	}
+	else {
+		panic("Unknown HP9000 Model");
+	}
+#ifdef CONFIG_SERIAL_8250_CONSOLE
+	hp300_setup_serial_console();
 #endif
-  mach_max_dma_address = 0xffffffff;
 }
diff -Naur linux-2.6.8.1/arch/m68k/hp300/ints.c linux-2.6.8.1-m68k-20040817/arch/m68k/hp300/ints.c
--- linux-2.6.8.1/arch/m68k/hp300/ints.c	2004-08-14 20:55:48.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/arch/m68k/hp300/ints.c	2004-07-10 06:52:29.000000000 +1000
@@ -57,14 +57,21 @@
 	return IRQ_HANDLED;
 }
 
+static irqreturn_t hp300_badint(int irq, void *dev_id, struct pt_regs *fp)
+{
+	num_spurious += 1;
+	return IRQ_NONE;
+}
+
 irqreturn_t (*hp300_default_handler[SYS_IRQS])(int, void *, struct pt_regs *) = {
-	[0] = hp300_int_handler,
+	[0] = hp300_badint,
 	[1] = hp300_int_handler,
 	[2] = hp300_int_handler,
 	[3] = hp300_int_handler,
 	[4] = hp300_int_handler,
 	[5] = hp300_int_handler,
 	[6] = hp300_int_handler,
+	[7] = hp300_int_handler
 };
 
 /* dev_id had better be unique to each handler because it's the only way we have
diff -Naur linux-2.6.8.1/arch/m68k/hp300/reboot.S linux-2.6.8.1-m68k-20040817/arch/m68k/hp300/reboot.S
--- linux-2.6.8.1/arch/m68k/hp300/reboot.S	2004-08-14 20:54:52.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/arch/m68k/hp300/reboot.S	2004-07-10 06:52:29.000000000 +1000
@@ -13,23 +13,4 @@
 
 	.globl	hp300_reset
 hp300_reset:
-	.chip	68030
-	oriw    #0x0700,%sr			/* cli() */
-	movel	hp300_phys_ram_base, %d1
-	movel	#0, %d0
-	movec	%d0, %vbr			/* reset vector table */
-	lea	zero, %a0
-	lea	1f, %a1
-	add	%d1, %a0
-	add	%d1, %a1
-	pmove	%tc, %a0@
-	bclr	#7, %a0@
-	pmove	%a0@, %tc			/* goodbye MMU */
-	jmp	%a1@
-1:	movel	#0x808, %d0
-	movec	%d0, %cacr			/* cache off */
-	moveb	#0, 0x1ffff
-	movel	#0x1a4, %a0
-	jmp	%a0@
-
-zero:	.quad	0
+	jmp	hp300_reset
diff -Naur linux-2.6.8.1/arch/m68k/hp300/time.c linux-2.6.8.1-m68k-20040817/arch/m68k/hp300/time.c
--- linux-2.6.8.1/arch/m68k/hp300/time.c	2004-08-14 20:55:48.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/arch/m68k/hp300/time.c	2004-07-10 06:52:29.000000000 +1000
@@ -17,6 +17,7 @@
 #include <asm/io.h>
 #include <asm/system.h>
 #include <asm/traps.h>
+#include <asm/blinken.h>
 #include "ints.h"
 
 /* Clock hardware definitions */
@@ -38,11 +39,13 @@
 
 static irqreturn_t hp300_tick(int irq, void *dev_id, struct pt_regs *regs)
 {
-  unsigned long tmp;
-  irqreturn_t (*vector)(int, void *, struct pt_regs *) = dev_id;
-  in_8(CLOCKBASE + CLKSR);
-  asm volatile ("movpw %1@(5),%0" : "=d" (tmp) : "a" (CLOCKBASE));
-  return vector(irq, NULL, regs);
+	unsigned long tmp;
+	irqreturn_t (*vector)(int, void *, struct pt_regs *) = dev_id;
+	in_8(CLOCKBASE + CLKSR);
+	asm volatile ("movpw %1@(5),%0" : "=d" (tmp) : "a" (CLOCKBASE));
+	/* Turn off the network and SCSI leds */
+	blinken_leds(0, 0xe0);
+	return vector(irq, NULL, regs);
 }
 
 unsigned long hp300_gettimeoffset(void)
diff -Naur linux-2.6.8.1/arch/m68k/kernel/asm-offsets.c linux-2.6.8.1-m68k-20040817/arch/m68k/kernel/asm-offsets.c
--- linux-2.6.8.1/arch/m68k/kernel/asm-offsets.c	2004-08-14 20:54:48.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/arch/m68k/kernel/asm-offsets.c	2004-01-07 01:41:27.000000000 +1100
@@ -31,6 +31,7 @@
 	DEFINE(TASK_SIGPENDING, offsetof(struct task_struct, thread.work.sigpending));
 	DEFINE(TASK_NOTIFY_RESUME, offsetof(struct task_struct, thread.work.notify_resume));
 	DEFINE(TASK_THREAD, offsetof(struct task_struct, thread));
+	DEFINE(TASK_INFO, offsetof(struct task_struct, thread.info));
 	DEFINE(TASK_MM, offsetof(struct task_struct, mm));
 	DEFINE(TASK_ACTIVE_MM, offsetof(struct task_struct, active_mm));
 
@@ -45,6 +46,10 @@
 	DEFINE(THREAD_FPCNTL, offsetof(struct thread_struct, fpcntl));
 	DEFINE(THREAD_FPSTATE, offsetof(struct thread_struct, fpstate));
 
+	/* offsets into the thread_info struct */
+	DEFINE(TINFO_PREEMPT, offsetof(struct thread_info, preempt_count));
+	DEFINE(HARDIRQ_SHIFT, HARDIRQ_SHIFT);
+
 	/* offsets into the pt_regs */
 	DEFINE(PT_D0, offsetof(struct pt_regs, d0));
 	DEFINE(PT_ORIG_D0, offsetof(struct pt_regs, orig_d0));
diff -Naur linux-2.6.8.1/arch/m68k/kernel/bios32.c linux-2.6.8.1-m68k-20040817/arch/m68k/kernel/bios32.c
--- linux-2.6.8.1/arch/m68k/kernel/bios32.c	2004-08-14 20:55:33.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/arch/m68k/kernel/bios32.c	2004-04-05 23:09:05.000000000 +1000
@@ -292,7 +292,7 @@
 
 	DBG_DEVS(("layout_bus: starting bus %d\n", bus->number));
 
-	if (!bus->devices && !bus->children)
+	if (list_empty(&bus->devices) && list_empty(&bus->children))
 		return;
 
 	/*
diff -Naur linux-2.6.8.1/arch/m68k/kernel/head.S linux-2.6.8.1-m68k-20040817/arch/m68k/kernel/head.S
--- linux-2.6.8.1/arch/m68k/kernel/head.S	2004-08-14 20:56:24.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/arch/m68k/kernel/head.S	2004-07-10 06:52:29.000000000 +1000
@@ -24,6 +24,7 @@
 ** 1998/08/30 David Kilzer: Added support for font_desc structures
 **            for linux-2.1.115
 ** 9/02/11  Richard Zidlicky: added Q40 support (initial vesion 99/01/01)
+** 2004/05/13 Kars de Jong: Finalised HP300 support
 **
 ** This file is subject to the terms and conditions of the GNU General Public
 ** License. See the file README.legal in the main directory of this archive
@@ -313,9 +314,6 @@
 #ifdef CONFIG_Q40
 .globl q40_mem_cptr
 #endif
-#ifdef CONFIG_HP300
-.globl hp300_phys_ram_base
-#endif
 
 CPUTYPE_040	= 1	/* indicates an 040 */
 CPUTYPE_060	= 2	/* indicates an 060 */
@@ -467,7 +465,7 @@
 func_define	mmu_get_page_table_entry,2
 func_define	mmu_print
 func_define	get_new_page
-#ifdef CONFIG_HP300
+#if defined(CONFIG_HP300) || defined(CONFIG_APOLLO)
 func_define	set_leds
 #endif
 
@@ -594,6 +592,7 @@
 	.long	MACH_BVME6000, BVME6000_BOOTI_VERSION
 	.long	MACH_MAC, MAC_BOOTI_VERSION
 	.long	MACH_Q40, Q40_BOOTI_VERSION
+	.long	MACH_HP300, HP300_BOOTI_VERSION
 	.long	0
 1:	jra	__start
 
@@ -605,65 +604,6 @@
 	jra	__start
 __INIT
 ENTRY(__start)
-
-#ifdef CONFIG_HP300
-/* This is a hack.  The HP NetBSD bootloader loads us at an arbitrary
-   address (apparently 0xff002000 in practice) which is not good if we need
-   to be able to map this to VA 0x1000.  We could do it with pagetables but
-   a better solution seems to be to relocate the kernel in physical memory
-   before we start.
-
-   So, we copy the entire kernel image (code+data+bss) down to the 16MB
-   boundary that marks the start of RAM.  This is slightly tricky because
-   we must not overwrite the copying code itself. :-)  */
-
-/* 15/5/98.  The start address of physical RAM changes depending on how much
-   RAM is present.  This is actually a blessing in disguise as it provides
-   a way for us to work out the RAM size rather than hardwiring it.  */
-
-	lea	%pc@(_start),%a0
-	movel	%a0,%d6
-	and	#0xffff0000, %d6
-	lea	%pc@(hp300_phys_ram_base),%a0
-	movel	%d6, %a0@
-	movel	%pc@(L(custom)),%a3
-	moveb	#0xfe,%d7
-	moveb	%d7,%a3@(0x1ffff)
-	lea	%pc@(Lcopystart),%a0
-	lea	%pc@(Lcopyend),%a1
-	movel	%d6,%a2			/* Start of physical RAM */
-1:	moveb	%a0@+,%d0
-	moveb	%d0,%a2@+
-	cmpl	%a0,%a1
-	jbne	1b
-	movel	%d6,%a2
-	moveb	#0xfd,%d7
-	moveb	%d7,%a3@(0x1ffff)
-	lea	%pc@(_stext),%a0
-	lea	%pc@(_end),%a1
-	jmp	%a2@
-
-Lcopystart:
-	moveb	#0xf7,%d7
-	moveb	%d7,%a3@(0x1ffff)
-	movel	%d6,%a2	/* Start of kernel */
-	add	#0x1000,%a2
-1:	moveb	%a0@+,%d0
-	moveb	%d0,%a2@+
-	cmpl	%a0,%a1
-	jbne	1b
-	moveb	#0,%d7
-	moveb	%d7,%a3@(0x1ffff)
-	movel	%d6,%a0
-	addl	#Lstart1,%a0
-	jmp	%a0@
-Lcopyend:
-
-Lstart1:
-	moveb	#0x3f,%d7
-	moveb	%d7,%a3@(0x1ffff)
-#endif /* CONFIG_HP300 */
-
 /*
  * Setup initial stack pointer
  */
@@ -672,8 +612,6 @@
 /*
  * Record the CPU and machine type.
  */
-
-#ifndef CONFIG_HP300
 	get_bi_record	BI_MACHTYPE
 	lea	%pc@(m68k_machtype),%a1
 	movel	%a0@,%a1@
@@ -689,23 +627,8 @@
 	get_bi_record	BI_CPUTYPE
 	lea	%pc@(m68k_cputype),%a1
 	movel	%a0@,%a1@
-#else /* CONFIG_HP300 */
-	/* FIXME HP300 doesn't use bootinfo yet */
-	movel	#MACH_HP300,%d4
-	lea	%pc@(m68k_machtype),%a0
-	movel	%d4,%a0@
-	movel	#FPU_68881,%d0
-	lea	%pc@(m68k_fputype),%a0
-	movel	%d0,%a0@
-	movel	#MMU_68030,%d0
-	lea	%pc@(m68k_mmutype),%a0
-	movel	%d0,%a0@
-	movel	#CPU_68030,%d0
-	lea	%pc@(m68k_cputype),%a0
-	movel	%d0,%a0@
 
-	leds(0x1)
-#endif /* CONFIG_HP300 */
+	leds	0x1
 
 #ifdef CONFIG_MAC
 /*
@@ -956,6 +879,26 @@
 
 #endif
 
+#ifdef CONFIG_HP300
+	is_not_hp300(L(nothp))
+
+	/* Get the address of the UART for serial debugging */
+	get_bi_record	BI_HP300_UART_ADDR
+	tstl	%d0
+	jbmi	1f
+	movel	%a0@,%d3
+	lea	%pc@(L(uartbase)),%a0
+	movel	%d3,%a0@
+	get_bi_record	BI_HP300_UART_SCODE
+	tstl	%d0
+	jbmi	1f
+	movel	%a0@,%d3
+	lea	%pc@(L(uart_scode)),%a0
+	movel	%d3,%a0@
+1:
+L(nothp):
+#endif
+
 /*
  * Initialize serial port
  */
@@ -979,9 +922,7 @@
 
 	putc	'\n'
 	putc	'A'
-#ifdef CONFIG_HP300
-	leds(0x2)
-#endif /* CONFIG_HP300 */
+	leds	0x2
 	dputn	%pc@(L(cputype))
 	dputn	%pc@(m68k_supervisor_cachemode)
 	dputn	%pc@(m68k_pgtable_cachemode)
@@ -1124,16 +1065,30 @@
 #ifdef CONFIG_HP300
 	is_not_hp300(L(nothp300))
 
-/* On the HP300, we map the ROM, INTIO and DIO regions (phys. 0x00xxxxxx)
-   by mapping 32MB from 0xf0xxxxxx -> 0x00xxxxxx) using an 030 early
-   termination page descriptor.  The ROM mapping is needed because the LEDs
-   are mapped there too.  */
+	/* On the HP300, we map the ROM, INTIO and DIO regions (phys. 0x00xxxxxx)
+	 * by mapping 32MB (on 020/030) or 16 MB (on 040) from 0xf0xxxxxx -> 0x00xxxxxx).
+	 * The ROM mapping is needed because the LEDs are mapped there too.
+	 */
+
+	is_040(1f)
 
+	/*
+	 * 030: Map the 32Meg range physical 0x0 upto logical 0xf000.0000
+	 */
 	mmu_map	#0xf0000000,#0,#0x02000000,#_PAGE_NOCACHE030
 
-L(nothp300):
+	jbra	L(mmu_init_done)
 
-#endif
+1:
+	/*
+	 * 040: Map the 16Meg range physical 0x0 upto logical 0xf000.0000
+	 */
+	mmu_map #0xf0000000,#0,#0x01000000,#_PAGE_NOCACHE_S
+
+	jbra	L(mmu_init_done)
+
+L(nothp300):
+#endif /* CONFIG_HP300 */
 
 #ifdef CONFIG_MVME147
 
@@ -1480,15 +1435,23 @@
 #ifdef CONFIG_HP300
 	is_not_hp300(1f)
 	/*
-	 * Fix up the custom register to point to the new location of the LEDs.
+	 * Fix up the iobase register to point to the new location of the LEDs.
 	 */
-	movel	#0xf0000000,L(custom)
+	movel	#0xf0000000,L(iobase)
 
 	/*
 	 * Energise the FPU and caches.
 	 */
+	is_040(1f)
 	movel	#0x60,0xf05f400c
-1:
+	jbra	2f
+
+	/*
+	 * 040: slightly different, apparently.
+	 */
+1:	movew	#0,0xf05f400e
+	movew	#0x64,0xf05f400e
+2:
 #endif
 
 #ifdef CONFIG_SUN3X
@@ -1585,7 +1548,6 @@
 
 	movel	ARG1,%d0
 	lea	%pc@(_end),%a0
-#ifndef CONFIG_HP300
 1:	tstw	%a0@(BIR_TAG)
 	jeq	3f
 	cmpw	%a0@(BIR_TAG),%d0
@@ -1599,7 +1561,6 @@
 3:	moveq	#-1,%d0
 	lea	%a0@(BIR_SIZE),%a0
 4:
-#endif /* CONFIG_HP300 */
 func_return	get_bi_record
 
 
@@ -3013,6 +2974,10 @@
 /* We count on the PROM initializing SIO1 */
 #endif
 
+#ifdef CONFIG_HP300
+/* We count on the boot loader initialising the UART */
+#endif
+
 L(serial_init_done):
 func_return	serial_init
 
@@ -3205,9 +3170,31 @@
 1:      moveb   %a1@(LSRB0),%d0
 	andb	#0x4,%d0
 	beq	1b
+	jbra	L(serial_putc_done)
 2:
 #endif
 
+#ifdef CONFIG_HP300
+	is_not_hp300(3f)
+	movl    %pc@(L(iobase)),%a1
+	addl	%pc@(L(uartbase)),%a1
+	movel	%pc@(L(uart_scode)),%d1	/* Check the scode */
+	jmi	3f			/* Unset? Exit */
+	cmpi	#256,%d1		/* APCI scode? */
+	jeq	2f
+1:      moveb   %a1@(DCALSR),%d1	/* Output to DCA */
+	andb	#0x20,%d1
+	beq	1b
+	moveb	%d0,%a1@(DCADATA)
+	jbra	L(serial_putc_done)
+2:	moveb	%a1@(APCILSR),%d1	/* Output to APCI */
+	andb	#0x20,%d1
+	beq	2b
+	moveb	%d0,%a1@(APCIDATA)
+	jbra	L(serial_putc_done)
+3:
+#endif
+	
 L(serial_putc_done):
 func_return	serial_putc
 
@@ -3295,7 +3282,7 @@
 	movel	ARG1,%d0
 #ifdef CONFIG_HP300
 	is_not_hp300(1f)
-	movel	%pc@(L(custom)),%a0
+	movel	%pc@(L(iobase)),%a0
 	moveb	%d0,%a0@(0x1ffff)
 	jra	2f
 #endif
@@ -3829,10 +3816,6 @@
 __INITDATA
 	.align	4
 
-#ifdef CONFIG_HP300
-hp300_phys_ram_base:
-#endif
-
 #if defined(CONFIG_ATARI) || defined(CONFIG_AMIGA) || \
     defined(CONFIG_HP300) || defined(CONFIG_APOLLO)
 L(custom):
@@ -3924,6 +3907,17 @@
 LCPUCTRL     = 0x10100
 #endif
 
+#if defined(CONFIG_HP300)
+DCADATA	     = 0x11
+DCALSR	     = 0x1b
+APCIDATA     = 0x00
+APCILSR      = 0x14
+L(uartbase):
+	.long	0
+L(uart_scode):
+	.long	-1
+#endif
+
 __FINIT
 	.data
 	.align	4
diff -Naur linux-2.6.8.1/arch/m68k/kernel/m68k_ksyms.c linux-2.6.8.1-m68k-20040817/arch/m68k/kernel/m68k_ksyms.c
--- linux-2.6.8.1/arch/m68k/kernel/m68k_ksyms.c	2004-08-14 20:56:00.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/arch/m68k/kernel/m68k_ksyms.c	2003-10-21 09:39:45.000000000 +1000
@@ -47,6 +47,7 @@
 EXPORT_SYMBOL(iounmap);
 EXPORT_SYMBOL(kernel_set_cachemode);
 #endif /* !CONFIG_SUN3 */
+EXPORT_SYMBOL(flush_icache_user_range);
 EXPORT_SYMBOL(m68k_debug_device);
 EXPORT_SYMBOL(mach_hwclk);
 EXPORT_SYMBOL(mach_get_ss);
diff -Naur linux-2.6.8.1/arch/m68k/kernel/process.c linux-2.6.8.1-m68k-20040817/arch/m68k/kernel/process.c
--- linux-2.6.8.1/arch/m68k/kernel/process.c	2004-08-14 20:56:24.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/arch/m68k/kernel/process.c	2004-08-16 01:24:11.000000000 +1000
@@ -245,7 +245,7 @@
 	unsigned long stack_offset, *retp;
 
 	stack_offset = THREAD_SIZE - sizeof(struct pt_regs);
-	childregs = (struct pt_regs *) ((unsigned long) (p->thread_info) + stack_offset);
+	childregs = (struct pt_regs *) ((unsigned long) (p->stack) + stack_offset);
 
 	*childregs = *regs;
 	childregs->d0 = 0;
@@ -390,7 +390,7 @@
 	if (!p || p == current || p->state == TASK_RUNNING)
 		return 0;
 
-	stack_page = (unsigned long)(p->thread_info);
+	stack_page = (unsigned long)(p->stack);
 	fp = ((struct switch_stack *)p->thread.ksp)->a6;
 	do {
 		if (fp < stack_page+sizeof(struct thread_info) ||
diff -Naur linux-2.6.8.1/arch/m68k/kernel/setup.c linux-2.6.8.1-m68k-20040817/arch/m68k/kernel/setup.c
--- linux-2.6.8.1/arch/m68k/kernel/setup.c	2004-08-14 20:56:22.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/arch/m68k/kernel/setup.c	2004-08-16 01:24:11.000000000 +1000
@@ -109,6 +109,7 @@
 extern int bvme6000_parse_bootinfo(const struct bi_record *);
 extern int mvme16x_parse_bootinfo(const struct bi_record *);
 extern int mvme147_parse_bootinfo(const struct bi_record *);
+extern int hp300_parse_bootinfo(const struct bi_record *);
 
 extern void config_amiga(void);
 extern void config_atari(void);
@@ -175,6 +176,8 @@
 		    unknown = mvme16x_parse_bootinfo(record);
 		else if (MACH_IS_MVME147)
 		    unknown = mvme147_parse_bootinfo(record);
+		else if (MACH_IS_HP300)
+		    unknown = hp300_parse_bootinfo(record);
 		else
 		    unknown = 1;
 	}
@@ -204,20 +207,8 @@
 	int i;
 	char *p, *q;
 
-	if (!MACH_IS_HP300) {
-		/* The bootinfo is located right after the kernel bss */
-		m68k_parse_bootinfo((const struct bi_record *)&_end);
-	} else {
-		/* FIXME HP300 doesn't use bootinfo yet */
-		extern unsigned long hp300_phys_ram_base;
-		unsigned long hp300_mem_size = 0xffffffff-hp300_phys_ram_base;
-		m68k_cputype = CPU_68030;
-		m68k_fputype = FPU_68882;
-		m68k_memory[0].addr = hp300_phys_ram_base;
-		/* 0.5M fudge factor */
-		m68k_memory[0].size = hp300_mem_size-512*1024;
-		m68k_num_memory++;
-	}
+	/* The bootinfo is located right after the kernel bss */
+	m68k_parse_bootinfo((const struct bi_record *)&_end);
 
 	if (CPU_IS_040)
 		m68k_is040or060 = 4;
diff -Naur linux-2.6.8.1/arch/m68k/mm/Makefile linux-2.6.8.1-m68k-20040817/arch/m68k/mm/Makefile
--- linux-2.6.8.1/arch/m68k/mm/Makefile	2004-08-14 20:54:51.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/arch/m68k/mm/Makefile	2004-02-05 06:45:07.000000000 +1100
@@ -2,7 +2,7 @@
 # Makefile for the linux m68k-specific parts of the memory manager.
 #
 
-obj-y		:= init.o fault.o hwtest.o
+obj-y		:= cache.o init.o fault.o hwtest.o
 
 obj-$(CONFIG_MMU_MOTOROLA)	+= kmap.o memory.o motorola.o
 obj-$(CONFIG_MMU_SUN3)		+= sun3kmap.o sun3mmu.o
diff -Naur linux-2.6.8.1/arch/m68k/mm/cache.c linux-2.6.8.1-m68k-20040817/arch/m68k/mm/cache.c
--- linux-2.6.8.1/arch/m68k/mm/cache.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/arch/m68k/mm/cache.c	2004-04-05 23:09:06.000000000 +1000
@@ -0,0 +1,160 @@
+/*
+ *  linux/arch/m68k/mm/cache.c
+ *
+ *  Instruction cache handling
+ *
+ *  Copyright (C) 1995  Hamish Macdonald
+ */
+
+#include <asm/pgalloc.h>
+#include <asm/traps.h>
+
+
+static unsigned long virt_to_phys_slow(unsigned long vaddr, mm_segment_t fs)
+{
+	if (CPU_IS_060) {
+		mm_segment_t old_fs = get_fs();
+		unsigned long paddr;
+
+		set_fs(fs);
+
+		/* The PLPAR instruction causes an access error if the translation
+		 * is not possible. To catch this we use the same exception mechanism
+		 * as for user space accesses in <asm/uaccess.h>. */
+		asm volatile (".chip 68060\n"
+			      "1: plpar (%0)\n"
+			      ".chip 68k\n"
+			      "2:\n"
+			      ".section .fixup,\"ax\"\n"
+			      "   .even\n"
+			      "3: sub.l %0,%0\n"
+			      "   jra 2b\n"
+			      ".previous\n"
+			      ".section __ex_table,\"a\"\n"
+			      "   .align 4\n"
+			      "   .long 1b,3b\n"
+			      ".previous"
+			      : "=a" (paddr)
+			      : "0" (vaddr));
+		set_fs(old_fs);
+		return paddr;
+	} else if (CPU_IS_040) {
+		mm_segment_t old_fs = get_fs();
+		unsigned long mmusr;
+
+		set_fs(fs);
+
+		asm volatile (".chip 68040\n\t"
+			      "ptestr (%1)\n\t"
+			      "movec %%mmusr, %0\n\t"
+			      ".chip 68k"
+			      : "=r" (mmusr)
+			      : "a" (vaddr));
+		set_fs(old_fs);
+
+		if (mmusr & MMU_R_040)
+			return (mmusr & PAGE_MASK) | (vaddr & ~PAGE_MASK);
+	} else {
+		unsigned short mmusr;
+		unsigned long *descaddr;
+
+		asm volatile ("ptestr %3,%2@,#7,%0\n\t"
+			      "pmove %%psr,%1@"
+			      : "=a&" (descaddr)
+			      : "a" (&mmusr), "a" (vaddr), "d" (fs.seg));
+		if (mmusr & (MMU_I|MMU_B|MMU_L))
+			return 0;
+		descaddr = phys_to_virt((unsigned long)descaddr);
+		switch (mmusr & MMU_NUM) {
+		case 1:
+			return (*descaddr & 0xfe000000) | (vaddr & 0x01ffffff);
+		case 2:
+			return (*descaddr & 0xfffc0000) | (vaddr & 0x0003ffff);
+		case 3:
+			return (*descaddr & PAGE_MASK) | (vaddr & ~PAGE_MASK);
+		}
+	}
+	return 0;
+}
+
+/* Push n pages at kernel virtual address and clear the icache */
+/* RZ: use cpush %bc instead of cpush %dc, cinv %ic */
+void flush_icache_range(unsigned long address, unsigned long endaddr)
+{
+	if (CPU_IS_040_OR_060) {
+		address &= PAGE_MASK;
+
+		if (address >= PAGE_OFFSET && address < (unsigned long)high_memory) {
+			do {
+				asm volatile ("nop\n\t"
+					      ".chip 68040\n\t"
+					      "cpushp %%bc,(%0)\n\t"
+					      ".chip 68k"
+					      : : "a" (virt_to_phys((void *)address)));
+				address += PAGE_SIZE;
+			} while (address < endaddr);
+		} else {
+			do {
+				asm volatile ("nop\n\t"
+					      ".chip 68040\n\t"
+					      "cpushp %%bc,(%0)\n\t"
+					      ".chip 68k"
+					      : : "a" (virt_to_phys_slow(address, KERNEL_DS)));
+				address += PAGE_SIZE;
+			} while (address < endaddr);
+		}
+	} else {
+		unsigned long tmp;
+		asm volatile ("movec %%cacr,%0\n\t"
+			      "orw %1,%0\n\t"
+			      "movec %0,%%cacr"
+			      : "=&d" (tmp)
+			      : "di" (FLUSH_I));
+	}
+}
+
+void flush_icache_user_range(void *addr, unsigned long size)
+{
+	unsigned long address = (unsigned long)addr;
+	unsigned long endaddr = address + size;
+
+	if (CPU_IS_040_OR_060) {
+		address &= PAGE_MASK;
+
+		do {
+			asm volatile ("nop\n\t"
+				      ".chip 68040\n\t"
+				      "cpushp %%bc,(%0)\n\t"
+				      ".chip 68k"
+				      : : "a" (virt_to_phys_slow(address, get_fs())));
+			address += PAGE_SIZE;
+		} while (address < endaddr);
+	} else {
+		unsigned long tmp;
+		asm volatile ("movec %%cacr,%0\n\t"
+			      "orw %1,%0\n\t"
+			      "movec %0,%%cacr"
+			      : "=&d" (tmp)
+			      : "di" (FLUSH_I));
+	}
+}
+
+void flush_icache_user_page(struct vm_area_struct *vma, struct page *page,
+			    unsigned long addr, int len)
+{
+	if (CPU_IS_040_OR_060) {
+		asm volatile ("nop\n\t"
+			      ".chip 68040\n\t"
+			      "cpushp %%bc,(%0)\n\t"
+			      ".chip 68k"
+			      : : "a" (page_to_phys(page)));
+	} else {
+		unsigned long tmp;
+		asm volatile ("movec %%cacr,%0\n\t"
+			      "orw %1,%0\n\t"
+			      "movec %0,%%cacr"
+			      : "=&d" (tmp)
+			      : "di" (FLUSH_I));
+	}
+}
+
diff -Naur linux-2.6.8.1/arch/m68k/mm/memory.c linux-2.6.8.1-m68k-20040817/arch/m68k/mm/memory.c
--- linux-2.6.8.1/arch/m68k/mm/memory.c	2004-08-14 20:55:35.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/arch/m68k/mm/memory.c	2004-07-11 20:18:05.000000000 +1000
@@ -354,110 +354,6 @@
 #endif
 }
 
-static unsigned long virt_to_phys_slow(unsigned long vaddr)
-{
-	if (CPU_IS_060) {
-		mm_segment_t fs = get_fs();
-		unsigned long paddr;
-
-		set_fs(get_ds());
-
-		/* The PLPAR instruction causes an access error if the translation
-		 * is not possible. To catch this we use the same exception mechanism
-		 * as for user space accesses in <asm/uaccess.h>. */
-		asm volatile (".chip 68060\n"
-			      "1: plpar (%0)\n"
-			      ".chip 68k\n"
-			      "2:\n"
-			      ".section .fixup,\"ax\"\n"
-			      "   .even\n"
-			      "3: sub.l %0,%0\n"
-			      "   jra 2b\n"
-			      ".previous\n"
-			      ".section __ex_table,\"a\"\n"
-			      "   .align 4\n"
-			      "   .long 1b,3b\n"
-			      ".previous"
-			      : "=a" (paddr)
-			      : "0" (vaddr));
-		set_fs(fs);
-		return paddr;
-	} else if (CPU_IS_040) {
-		mm_segment_t fs = get_fs();
-		unsigned long mmusr;
-
-		set_fs(get_ds());
-
-		asm volatile (".chip 68040\n\t"
-			      "ptestr (%1)\n\t"
-			      "movec %%mmusr, %0\n\t"
-			      ".chip 68k"
-			      : "=r" (mmusr)
-			      : "a" (vaddr));
-		set_fs(fs);
-
-		if (mmusr & MMU_R_040)
-			return (mmusr & PAGE_MASK) | (vaddr & ~PAGE_MASK);
-	} else {
-		unsigned short mmusr;
-		unsigned long *descaddr;
-
-		asm volatile ("ptestr #5,%2@,#7,%0\n\t"
-			      "pmove %%psr,%1@"
-			      : "=a&" (descaddr)
-			      : "a" (&mmusr), "a" (vaddr));
-		if (mmusr & (MMU_I|MMU_B|MMU_L))
-			return 0;
-		descaddr = phys_to_virt((unsigned long)descaddr);
-		switch (mmusr & MMU_NUM) {
-		case 1:
-			return (*descaddr & 0xfe000000) | (vaddr & 0x01ffffff);
-		case 2:
-			return (*descaddr & 0xfffc0000) | (vaddr & 0x0003ffff);
-		case 3:
-			return (*descaddr & PAGE_MASK) | (vaddr & ~PAGE_MASK);
-		}
-	}
-	return 0;
-}
-
-/* Push n pages at kernel virtual address and clear the icache */
-/* RZ: use cpush %bc instead of cpush %dc, cinv %ic */
-void flush_icache_range(unsigned long address, unsigned long endaddr)
-{
-	if (CPU_IS_040_OR_060) {
-		address &= PAGE_MASK;
-
-		if (address >= PAGE_OFFSET && address < (unsigned long)high_memory) {
-			do {
-				asm volatile ("nop\n\t"
-					      ".chip 68040\n\t"
-					      "cpushp %%bc,(%0)\n\t"
-					      ".chip 68k"
-					      : : "a" (virt_to_phys((void *)address)));
-				address += PAGE_SIZE;
-			} while (address < endaddr);
-		} else {
-			do {
-				asm volatile ("nop\n\t"
-					      ".chip 68040\n\t"
-					      "cpushp %%bc,(%0)\n\t"
-					      ".chip 68k"
-					      : : "a" (virt_to_phys_slow(address)));
-				address += PAGE_SIZE;
-			} while (address < endaddr);
-		}
-	} else {
-		unsigned long tmp;
-		asm volatile ("movec %%cacr,%0\n\t"
-			      "orw %1,%0\n\t"
-			      "movec %0,%%cacr"
-			      : "=&d" (tmp)
-			      : "di" (FLUSH_I));
-	}
-}
-
-
 #ifndef CONFIG_SINGLE_MEMORY_CHUNK
 int mm_end_of_chunk (unsigned long addr, int len)
 {
diff -Naur linux-2.6.8.1/arch/m68k/mm/motorola.c linux-2.6.8.1-m68k-20040817/arch/m68k/mm/motorola.c
--- linux-2.6.8.1/arch/m68k/mm/motorola.c	2004-08-14 20:55:33.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/arch/m68k/mm/motorola.c	2004-08-05 07:02:05.000000000 +1000
@@ -258,7 +258,7 @@
 	printk ("before free_area_init\n");
 #endif
 	zones_size[0] = (mach_max_dma_address < (unsigned long)high_memory ?
-			 mach_max_dma_address : (unsigned long)high_memory);
+			 (mach_max_dma_address+1) : (unsigned long)high_memory);
 	zones_size[1] = (unsigned long)high_memory - zones_size[0];
 
 	zones_size[0] = (zones_size[0] - PAGE_OFFSET) >> PAGE_SHIFT;
diff -Naur linux-2.6.8.1/drivers/block/swim3.c linux-2.6.8.1-m68k-20040817/drivers/block/swim3.c
--- linux-2.6.8.1/drivers/block/swim3.c	2004-08-14 20:55:10.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/drivers/block/swim3.c	2004-08-16 01:24:24.000000000 +1000
@@ -302,7 +302,7 @@
 			continue;
 		start_request(&floppy_states[i]);
 	}
-	sti();
+	local_irq_enable();
 }
 
 static void start_request(struct floppy_state *fs)
@@ -368,7 +368,7 @@
 {
 	unsigned long flags;
 
-	save_flags(flags); cli();
+	local_irq_save(flags);
 	if (fs->timeout_pending)
 		del_timer(&fs->timeout);
 	fs->timeout.expires = jiffies + nticks;
@@ -376,7 +376,7 @@
 	fs->timeout.data = (unsigned long) fs;
 	add_timer(&fs->timeout);
 	fs->timeout_pending = 1;
-	restore_flags(flags);
+	local_irq_restore(flags);
 }
 
 static inline void scan_track(struct floppy_state *fs)
@@ -788,14 +788,13 @@
 {
 	unsigned long flags;
 
-	save_flags(flags);
-	cli();
+	local_irq_save(flags);
 	if (fs->state != idle) {
 		++fs->wanted;
 		while (fs->state != available) {
 			if (interruptible && signal_pending(current)) {
 				--fs->wanted;
-				restore_flags(flags);
+				local_irq_restore(flags);
 				return -EINTR;
 			}
 			interruptible_sleep_on(&fs->wait);
@@ -803,7 +802,7 @@
 		--fs->wanted;
 	}
 	fs->state = state;
-	restore_flags(flags);
+	local_irq_restore(flags);
 	return 0;
 }
 
@@ -811,11 +810,10 @@
 {
 	unsigned long flags;
 
-	save_flags(flags);
-	cli();
+	local_irq_save(flags);
 	fs->state = idle;
 	start_request(fs);
-	restore_flags(flags);
+	local_irq_restore(flags);
 }
 
 static int fd_eject(struct floppy_state *fs)
diff -Naur linux-2.6.8.1/drivers/char/16c552.h linux-2.6.8.1-m68k-20040817/drivers/char/16c552.h
--- linux-2.6.8.1/drivers/char/16c552.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/drivers/char/16c552.h	2001-10-22 19:34:32.000000000 +1000
@@ -0,0 +1,165 @@
+/*
+ * Definitions for the 16c552 DACE
+ * (dual-asynchronous-communications-element) used on the GVP
+ * IO-Extender. 
+ *
+ * Basically this is two 16c550 uarts's and a parallel port, which is
+ * why the serial definitions should be valid for the 16c550 uart
+ * aswell.
+ *
+ * Data was taken from National Semiconductors duart 16c552
+ * data-sheets and the Texas Instruments DACE 16c552 data-sheets (the
+ * NS version of the chip is _non_ standard and their data-sheets did
+ * cost me several wasted hours of work).
+ *
+ * This file is (C) 1995 Jes Sorensen (jds@kom.auc.dk)
+ *
+ * Moved from drivers/char/ to include/linux/, because it's useful
+ * on more than just the one card. I'm using it on the hp300 DCA
+ * serial driver, for example.  
+ *      -- Peter Maydell <pmaydell@chiark.greenend.org.uk> 05/1998
+ */
+
+#ifndef _16C552_H_
+#define _16C552_H_
+
+/* Serial stuff */
+
+struct uart_16c550 {
+	volatile u_char skip0;
+	volatile u_char RBR;
+	volatile u_char skip1;
+	volatile u_char IER;
+	volatile u_char skip2;
+	volatile u_char IIR;
+	volatile u_char skip3;
+	volatile u_char LCR;
+	volatile u_char skip4;
+	volatile u_char MCR;
+	volatile u_char skip5;
+	volatile u_char LSR;
+	volatile u_char skip6;
+	volatile u_char MSR;
+	volatile u_char skip7;
+	volatile u_char SCR;
+};
+
+#define THR RBR
+#define FCR IIR
+#define DLL RBR
+#define DLM IER
+#define AFR IIR
+
+/*
+ * Bit-defines for the various registers.
+ */
+
+
+/* IER */
+
+#define ERDAI         (1<<0)
+#define ETHREI        (1<<1)
+#define ELSI          (1<<2)
+#define EMSI          (1<<3)
+
+/* IIR - Interrupt Ident. Register */
+
+#define IRQ_PEND      (1<<0) /* NOTE: IRQ_PEND=0 implies irq pending */
+#define IRQ_ID1       (1<<1)
+#define IRQ_ID2       (1<<2)
+#define IRQ_ID3       (1<<3)
+#define FIFO_ENA0     (1<<6) /* Both these are set when FCR(1<<0)=1 */
+#define FIFO_ENA1     (1<<7)
+
+#define IRQ_RLS  (IRQ_ID1 | IRQ_ID2)
+#define IRQ_RDA  (IRQ_ID2)
+#define IRQ_CTI  (IRQ_ID2 | IRQ_ID3)
+#define IRQ_THRE (IRQ_ID1)
+#define IRQ_MS   0
+
+/* FCR - FIFO Control Register */
+
+#define FIFO_ENA      (1<<0)
+#define RCVR_FIFO_RES (1<<1)
+#define XMIT_FIFO_RES (1<<2)
+#define DMA_MODE_SEL  (1<<3)
+#define RCVR_TRIG_LSB (1<<6)
+#define RCVR_TRIG_MSB (1<<7)
+
+#define FIFO_TRIG_1   0x00
+#define FIFO_TRIG_4   RCVR_TRIG_LSB
+#define FIFO_TRIG_8   RCVR_TRIG_MSB
+#define FIFO_TRIG_14  RCVR_TRIG_LSB|RCVR_TRIG_MSB
+
+/* LCR - Line Control Register */
+
+#define WLS0          (1<<0)
+#define WLS1          (1<<1)
+#define STB           (1<<2)
+#define PEN           (1<<3)
+#define EPS           (1<<4)
+#define STICK_PARITY  (1<<5)
+#define SET_BREAK     (1<<6)
+#define DLAB          (1<<7)
+
+#define data_5bit      0x00
+#define data_6bit      0x01
+#define data_7bit      0x02
+#define data_8bit      0x03
+
+
+/* MCR - Modem Control Register */
+
+#define DTR           (1<<0)
+#define RTS           (1<<1)
+#define OUT1          (1<<2)
+#define OUT2          (1<<3)
+#define LOOP          (1<<4)
+
+/* LSR - Line Status Register */
+
+#define DR            (1<<0)
+#define OE            (1<<1)
+#define PE            (1<<2)
+#define FE            (1<<3)
+#define BI            (1<<4)
+#define THRE          (1<<5)
+#define TEMT          (1<<6)
+#define RCVR_FIFO_ERR (1<<7)
+
+/* MSR - Modem Status Register */
+
+#define DCTS          (1<<0)
+#define DDSR          (1<<1)
+#define TERI          (1<<2)
+#define DDCD          (1<<3)
+#define CTS           (1<<4)
+#define DSR           (1<<5)
+#define RING_I        (1<<6)
+#define DCD           (1<<7)
+
+/* AFR - Alternate Function Register */
+
+#define CONCUR_WRITE  (1<<0)
+#define BAUDOUT       (1<<1)
+#define RXRDY         (1<<2)
+
+/* Parallel stuff */
+
+/*
+ * Unfortunately National Semiconductors did not supply the
+ * specifications for the parallel port in the chip :-(
+ * TI succed though, so here they are :-)
+ *
+ * Defines for the bits can be found by including <linux/lp.h>
+ */
+struct IOEXT_par {
+	volatile u_char skip0;
+	volatile u_char DATA;
+	volatile u_char skip1;
+	volatile u_char STATUS;
+	volatile u_char skip2;
+	volatile u_char CTRL;
+};
+
+#endif
diff -Naur linux-2.6.8.1/drivers/char/ioext.h linux-2.6.8.1-m68k-20040817/drivers/char/ioext.h
--- linux-2.6.8.1/drivers/char/ioext.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/drivers/char/ioext.h	2001-10-22 19:34:32.000000000 +1000
@@ -0,0 +1,108 @@
+/*
+ * Shared data structure for GVP IO-Extender support.
+ *
+ * Merge of ioext.h and ser_ioext.h
+ */
+#ifndef _IOEXT_H_
+#define _IOEXT_H_
+
+#include <linux/config.h>
+#include <linux/netdevice.h>
+
+#include "16c552.h"
+
+#define MAX_IOEXT 5 /*
+		     * The maximum number of io-extenders is 5, as you
+		     * can't have more than 5 ZII boards in any Amiga.
+		     */
+
+#define UART_CLK 7372800
+
+#define IOEXT_BAUD_BASE (UART_CLK / 16)
+
+#define IOEXT_MAX_LINES 2
+
+#define IOEXT_PAR_PLIP  0x0001
+#define IOEXT_PAR_LP    0x0002
+
+
+/*
+ * Macros for the serial driver.
+ */
+#define curruart(info) ((struct uart_16c550 *)(info->port))
+
+#define ser_DTRon(info)  curruart(info)->MCR |=  DTR
+#define ser_RTSon(info)  curruart(info)->MCR |=  RTS
+#define ser_DTRoff(info) curruart(info)->MCR &= ~DTR
+#define ser_RTSoff(info) curruart(info)->MCR &= ~RTS
+
+
+/*
+ * CNTR defines (copied from the GVP SCSI-driver file gvp11.h
+ */
+#define GVP_BUSY	(1<<0)
+#define GVP_IRQ_PEND	(1<<1)
+#define GVP_IRQ_ENA 	(1<<3)
+#define GVP_DIR_WRITE   (1<<4)
+
+
+/*
+ * CTRL defines 
+ */
+#define PORT0_MIDI   (1<<0)  /* CLR = DRIVERS         SET = MIDI      */
+#define PORT1_MIDI   (1<<1)  /* CLR = DRIVERS         SET = MIDI      */
+#define PORT0_DRIVER (1<<2)  /* CLR = RS232,          SET = MIDI      */
+#define PORT1_DRIVER (1<<3)  /* CLR = RS232,          SET = MIDI      */
+#define IRQ_SEL      (1<<4)  /* CLR = INT2,           SET = INT6      */
+#define ROM_BANK_SEL (1<<5)  /* CLR = LOW 32K,        SET = HIGH 32K  */
+#define PORT0_CTRL   (1<<6)  /* CLR = RTSx or RXRDYx, SET = RTSx ONLY */
+#define PORT1_CTRL   (1<<7)  /* CLR = RTSx or RXRDYx, SET = RTSx ONLY */
+
+
+/*
+ * This is the struct describing the registers on the IO-Extender.
+ * NOTE: The board uses a dual uart (16c552), which should be equal to
+ * two 16c550 uarts.
+ */
+typedef struct {
+	char gap0[0x41];
+	volatile unsigned char CNTR;	/* GVP DMAC CNTR (status register)   */
+	char gap1[0x11e];
+	struct uart_16c550 uart0;	/* The first uart                    */
+	char gap2[0xf0];
+	struct uart_16c550 uart1;	/* The second uart                   */
+	char gap3[0xf0];
+	struct IOEXT_par par;		/* The parallel port                 */
+	char gap4[0xfb];
+	volatile unsigned char CTRL;	/* The control-register on the board */
+} IOEXT_struct;
+
+
+typedef struct {
+	int num_uarts;
+	int line[IOEXT_MAX_LINES];
+	volatile struct uart_16c550 *uart[IOEXT_MAX_LINES];
+	IOEXT_struct *board;
+	int spurious_count;
+	unsigned char par_use;		/* IOEXT_PAR_xxx */
+#if defined(CONFIG_GVPIOEXT_PLIP) || defined(CONFIG_GVPIOEXT_PLIP_MODULE)
+	struct nt_device *dev;
+#endif
+#if defined(CONFIG_GVPIOEXT_LP) || defined(CONFIG_GVPIOEXT_LP_MODULE)
+	struct lp_struct *lp_table;
+	int lp_dev;
+	int lp_interrupt;
+#endif
+} IOExtInfoType;
+
+/* Number of detected boards.  */
+extern int ioext_num;
+extern IOExtInfoType ioext_info[MAX_IOEXT];
+
+void ioext_plip_interrupt(struct net_device *dev, int *spurious_count);
+void ioext_lp_interrupt(int dev, int *spurious_count);
+
+extern struct net_device ioext_dev_plip[3];
+extern struct lp_struct ioext_lp_table[1];
+
+#endif
diff -Naur linux-2.6.8.1/drivers/char/mc68681.h linux-2.6.8.1-m68k-20040817/drivers/char/mc68681.h
--- linux-2.6.8.1/drivers/char/mc68681.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/drivers/char/mc68681.h	2001-10-22 19:34:32.000000000 +1000
@@ -0,0 +1,131 @@
+#ifndef _MC68681_H_
+#define _MC68681_H_
+
+/* 
+ * This describes an MC68681 DUART. It has almost only overlayed registers, which
+ * the structure very ugly.
+ * Note that the ri-register isn't really a register of the duart but a kludge of bsc
+ * to make the ring indicator available.
+ * 
+ * The data came from the MFC-31-Developer Kit (from Ralph Seidel,
+ * zodiac@darkness.gun.de) and the data sheet of Phillip's clone device (SCN68681)
+ * (from Richard Hirst, srh@gpt.co.uk)
+ *
+ * 11.11.95 copyright Joerg Dorchain (dorchain@mpi-sb.mpg.de)
+ *
+ */
+
+struct duarthalf {
+union {
+volatile u_char mr1; /* rw */
+volatile u_char mr2; /* rw */
+}  mr;
+volatile u_char ri;   /* special, read */
+union {
+volatile u_char sr;  /* read */
+volatile u_char csr; /* write */
+} sr_csr;
+u_char pad1;
+volatile u_char cr; /* write */
+u_char pad2;
+union {
+volatile u_char rhr; /* read */
+volatile u_char thr; /* write */
+} hr;
+u_char pad3;
+};
+
+struct duart {
+struct duarthalf pa;
+union {
+volatile u_char ipcr; /* read */
+volatile u_char acr;  /* write */
+} ipcr_acr;
+u_char pad1;
+union {
+volatile u_char isr; /* read */
+volatile u_char imr; /* write */
+} ir;
+u_char pad2;
+volatile u_char ctu;
+u_char pad3;
+volatile u_char ctl;
+u_char pad4;
+struct duarthalf pb;
+volatile u_char ivr;
+u_char pad5;
+union {
+volatile u_char ipr; /* read */
+volatile u_char opcr; /* write */
+} ipr_opcr;
+u_char pad6;
+union {
+volatile u_char start; /* read */
+volatile u_char sopc; /* write */
+} start_sopc;
+u_char pad7;
+union {
+volatile u_char stop; /* read */
+volatile u_char ropc; /* write */
+} stop_ropc;
+u_char pad8;
+};
+
+#define MR1_BITS 3
+#define MR1_5BITS 0
+#define MR1_6BITS 1
+#define MR1_7BITS 2
+#define MR1_8BITS 3
+
+#define MR1_PARITY_ODD 4
+
+#define MR1_PARITY 24
+#define MR1_PARITY_WITH 0
+#define MR1_PARITY_FORCE 8
+#define MR1_PARITY_NO 16
+#define MR1_PARITY_MULTIDROP 24
+
+#define MR1_ERROR_BLOCK 32
+#define MR1_FFULL_IRQ 64
+#define MR1_RxRTS_ON 128
+
+#define MR2_STOPS 15
+#define MR2_1STOP 7
+#define MR2_2STOP 15
+
+#define MR2_CTS_ON 16
+#define MR2_TxRTS_ON 32
+
+#define MR2_MODE 192
+#define MR2_NORMAL 0
+#define MR2_ECHO 64
+#define MR2_LOCALLOOP 128
+#define MR2_REMOTELOOP 192
+
+#define CR_RXCOMMAND 3
+#define CR_NONE 0
+#define CR_RX_ON 1
+#define CR_RX_OFF 2
+#define CR_TXCOMMAND 12
+#define CR_TX_ON 4
+#define CR_TX_OFF 8
+#define CR_MISC 112
+#define CR_RESET_MR 16
+#define CR_RESET_RX 32
+#define CR_RESET_TX 48
+#define CR_RESET_ERR 64
+#define CR_RESET_BREAK 80
+#define CR_START_BREAK 96
+#define CR_STOP_BREAK 112
+
+#define SR_RXRDY 1
+#define SR_FFULL 2
+#define SR_TXRDY 4
+#define SR_TXEMPT 8
+#define SR_OVERRUN 16
+#define SR_PARITY 32
+#define SR_FRAMING 64
+#define SR_BREAK 128
+
+
+#endif
diff -Naur linux-2.6.8.1/drivers/char/plip_ioext.c linux-2.6.8.1-m68k-20040817/drivers/char/plip_ioext.c
--- linux-2.6.8.1/drivers/char/plip_ioext.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/drivers/char/plip_ioext.c	2002-11-12 07:02:38.000000000 +1100
@@ -0,0 +1,1058 @@
+/*
+ * plip_ioext: A parallel port "network" driver for GVP IO-Extender.
+ *
+ * Authors:	See drivers/net/plip.c
+ *              IO-Extender version by Steve Bennett, <msteveb@ozemail.com.au>
+ *
+ * This driver is for use with a 5-bit cable (LapLink (R) cable).
+ */
+
+static const char *version = "NET3 PLIP version 2.2/m68k";
+
+#define __NO_VERSION__
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/termios.h>
+#include <linux/tty.h>
+#include <linux/serial.h>
+
+#include <asm/setup.h>
+#include <asm/irq.h>
+#include <asm/amigahw.h>
+#include <asm/amigaints.h>
+#include <linux/zorro.h>
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/fcntl.h>
+#include <linux/string.h>
+#include <linux/ptrace.h>
+#include <linux/if_ether.h>
+
+#include <asm/system.h>
+
+#include <linux/in.h>
+#include <linux/delay.h>
+/*#include <linux/lp_m68k.h>*/
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/skbuff.h>
+#include <linux/if_plip.h>
+
+#include <linux/tqueue.h>
+#include <linux/ioport.h>
+#include <asm/bitops.h>
+#include <asm/byteorder.h>
+
+#include "ioext.h"
+
+#define DEBUG 0
+
+/* Map 'struct device *' to our control structure */
+#define PLIP_DEV(DEV) (&ioext_info[(DEV)->irq])
+
+/************************************************************************
+**
+** PLIP definitions
+**
+*************************************************************************
+*/
+
+/* Use 0 for production, 1 for verification, >2 for debug */
+#ifndef NET_DEBUG
+#define NET_DEBUG 2
+#endif
+static unsigned int net_debug = NET_DEBUG;
+
+/* In micro second */
+#define PLIP_DELAY_UNIT       1
+
+/* Connection time out = PLIP_TRIGGER_WAIT * PLIP_DELAY_UNIT usec */
+#define PLIP_TRIGGER_WAIT	 500
+
+/* Nibble time out = PLIP_NIBBLE_WAIT * PLIP_DELAY_UNIT usec */
+#define PLIP_NIBBLE_WAIT        3000
+
+#define PAR_DATA(dev)     ((dev)->base_addr+0)
+#define PAR_STATUS(dev)   ((dev)->base_addr+2)
+#define PAR_CONTROL(dev)  ((dev)->base_addr+4)
+
+static void enable_par_irq(struct device *dev, int on);
+static int plip_init(struct device *dev);
+
+/* Bottom halfs */
+static void plip_kick_bh(struct device *dev);
+static void plip_bh(struct device *dev);
+
+/* Functions for DEV methods */
+static int plip_rebuild_header(struct sk_buff *skb);
+static int plip_tx_packet(struct sk_buff *skb, struct device *dev);
+static int plip_open(struct device *dev);
+static int plip_close(struct device *dev);
+static struct enet_statistics *plip_get_stats(struct device *dev);
+static int plip_config(struct device *dev, struct ifmap *map);
+static int plip_ioctl(struct device *dev, struct ifreq *ifr, int cmd);
+
+enum plip_connection_state {
+	PLIP_CN_NONE=0,
+	PLIP_CN_RECEIVE,
+	PLIP_CN_SEND,
+	PLIP_CN_CLOSING,
+	PLIP_CN_ERROR
+};
+
+enum plip_packet_state {
+	PLIP_PK_DONE=0,
+	PLIP_PK_TRIGGER,
+	PLIP_PK_LENGTH_LSB,
+	PLIP_PK_LENGTH_MSB,
+	PLIP_PK_DATA,
+	PLIP_PK_CHECKSUM
+};
+
+enum plip_nibble_state {
+	PLIP_NB_BEGIN,
+	PLIP_NB_1,
+	PLIP_NB_2,
+};
+
+struct plip_local {
+	enum plip_packet_state state;
+	enum plip_nibble_state nibble;
+	union {
+		struct {
+#if defined(__LITTLE_ENDIAN)
+			unsigned char lsb;
+			unsigned char msb;
+#elif defined(__BIG_ENDIAN)
+			unsigned char msb;
+			unsigned char lsb;
+#else
+#error  "Please fix the endianness defines in <asm/byteorder.h>"
+#endif            
+		} b;
+		unsigned short h;
+	} length;
+	unsigned short byte;
+	unsigned char  checksum;
+	unsigned char  data;
+	struct sk_buff *skb;
+};
+
+struct net_local {
+	struct enet_statistics enet_stats;
+	struct tq_struct immediate;
+	struct tq_struct deferred;
+	struct plip_local snd_data;
+	struct plip_local rcv_data;
+	unsigned long  trigger;
+	unsigned long  nibble;
+	enum plip_connection_state connection;
+	unsigned short timeout_count;
+	char is_deferred;
+	int (*orig_rebuild_header)(struct sk_buff *skb);
+};
+
+struct device ioext_dev_plip[] = {
+	{
+		"plip0",
+		0, 0, 0, 0,    /* memory */
+		0, 0,    /* base, irq */
+		0, 0, 0, NULL, plip_init 
+	},
+	{
+		"plip1",
+		0, 0, 0, 0,    /* memory */
+		0, 0,    /* base, irq */
+		0, 0, 0, NULL, plip_init 
+	},
+	{
+		"plip2",
+		0, 0, 0, 0,    /* memory */
+		0, 0,    /* base, irq */
+		0, 0, 0, NULL, plip_init 
+	}
+};
+
+/*
+ * Check for and handle an interrupt for this PLIP device.
+ *
+ */
+void ioext_plip_interrupt(struct device *dev, int *spurious_count)
+{
+	struct net_local *nl;
+	struct plip_local *rcv;
+	unsigned char c0;
+	unsigned long flags;
+
+	nl = (struct net_local *)dev->priv;
+	rcv = &nl->rcv_data;
+
+	c0 = z_readb(PAR_STATUS(dev));
+
+	if (dev->interrupt) {
+		return;
+	}
+
+	if ((c0 & 0xf8) != 0xc0) {
+		/* Not for us */
+		++*spurious_count;
+		return;
+	}
+
+	*spurious_count = 0;
+	dev->interrupt = 1;
+
+	local_irq_save(flags);
+
+	switch (nl->connection) {
+	case PLIP_CN_CLOSING:
+		dev->tbusy = 0;
+	case PLIP_CN_NONE:
+	case PLIP_CN_SEND:
+		dev->last_rx = jiffies;
+		rcv->state = PLIP_PK_TRIGGER;
+		nl->connection = PLIP_CN_RECEIVE;
+		nl->timeout_count = 0;
+		queue_task(&nl->immediate, &tq_immediate);
+		mark_bh(IMMEDIATE_BH);
+		local_irq_restore(flags);
+#if 0
+		printk("%s: receive irq in SEND/NONE/CLOSING (%d) ok\n",
+		       dev->name, nl->connection);
+#endif
+		break;
+
+	case PLIP_CN_RECEIVE:
+		local_irq_restore(flags);
+		printk("%s: receive interrupt when receiving packet\n",
+		       dev->name);
+		break;
+
+	case PLIP_CN_ERROR:
+		local_irq_restore(flags);
+		printk("%s: receive interrupt in error state\n", dev->name);
+		break;
+	}
+}
+
+
+/* Bottom half handler for the delayed request.
+   This routine is kicked by do_timer().
+   Request `plip_bh' to be invoked. */
+static void
+plip_kick_bh(struct device *dev)
+{
+	struct net_local *nl = (struct net_local *)dev->priv;
+
+	if (nl->is_deferred) {
+		queue_task(&nl->immediate, &tq_immediate);
+		mark_bh(IMMEDIATE_BH);
+	}
+}
+
+/* Forward declarations of internal routines */
+static int plip_none(struct device *, struct net_local *,
+		     struct plip_local *, struct plip_local *);
+static int plip_receive_packet(struct device *, struct net_local *,
+			       struct plip_local *, struct plip_local *);
+static int plip_send_packet(struct device *, struct net_local *,
+			    struct plip_local *, struct plip_local *);
+static int plip_connection_close(struct device *, struct net_local *,
+				 struct plip_local *, struct plip_local *);
+static int plip_error(struct device *, struct net_local *,
+		      struct plip_local *, struct plip_local *);
+static int plip_bh_timeout_error(struct device *dev, struct net_local *nl,
+				 struct plip_local *snd,
+				 struct plip_local *rcv,
+				 int error);
+
+#define OK        0
+#define TIMEOUT   1
+#define ERROR     2
+
+typedef int (*plip_func)(struct device *dev, struct net_local *nl,
+			 struct plip_local *snd, struct plip_local *rcv);
+
+static plip_func connection_state_table[] =
+{
+	plip_none,
+	plip_receive_packet,
+	plip_send_packet,
+	plip_connection_close,
+	plip_error
+};
+
+/*
+** enable_par_irq()
+** 
+** Enable or disable parallel irq for 'dev' according to 'on'.
+**
+** It is NOT possible to disable only the parallel irq.
+** So we disable the board interrupt instead. This means that
+** during reception of a PLIP packet, no serial interrupts can
+** happen. Sorry.
+*/
+static void enable_par_irq(struct device *dev, int on)
+{
+	if (on) {
+		PLIP_DEV(dev)->board->CNTR |= GVP_IRQ_ENA;
+	}
+	else {
+		PLIP_DEV(dev)->board->CNTR &= ~GVP_IRQ_ENA;
+	}
+}
+
+/* Bottom half handler of PLIP. */
+static void
+plip_bh(struct device *dev)
+{
+	struct net_local *nl = (struct net_local *)dev->priv;
+	struct plip_local *snd = &nl->snd_data;
+	struct plip_local *rcv = &nl->rcv_data;
+	plip_func f;
+	int r;
+
+	nl->is_deferred = 0;
+	f = connection_state_table[nl->connection];
+	if ((r = (*f)(dev, nl, snd, rcv)) != OK
+	    && (r = plip_bh_timeout_error(dev, nl, snd, rcv, r)) != OK) {
+		nl->is_deferred = 1;
+		queue_task(&nl->deferred, &tq_timer);
+	}
+}
+
+static int
+plip_bh_timeout_error(struct device *dev, struct net_local *nl,
+		      struct plip_local *snd, struct plip_local *rcv,
+		      int error)
+{
+	unsigned char c0;
+	unsigned long flags;
+
+	local_irq_save(flags);
+	if (nl->connection == PLIP_CN_SEND) {
+
+		if (error != ERROR) { /* Timeout */
+			nl->timeout_count++;
+			if ((snd->state == PLIP_PK_TRIGGER
+			     && nl->timeout_count <= 10)
+			    || nl->timeout_count <= 3) {
+				local_irq_restore(flags);
+				/* Try again later */
+				return TIMEOUT;
+			}
+			c0 = z_readb(PAR_STATUS(dev));
+			printk(KERN_INFO "%s: transmit timeout(%d,%02x)\n",
+			       dev->name, snd->state, c0);
+		}
+		nl->enet_stats.tx_errors++;
+		nl->enet_stats.tx_aborted_errors++;
+	} else if (nl->connection == PLIP_CN_RECEIVE) {
+		if (rcv->state == PLIP_PK_TRIGGER) {
+			/* Transmission was interrupted. */
+			local_irq_restore(flags);
+			return OK;
+		}
+		if (error != ERROR) { /* Timeout */
+			if (++nl->timeout_count <= 3) {
+				local_irq_restore(flags);
+				/* Try again later */
+				return TIMEOUT;
+			}
+			c0 = z_readb(PAR_STATUS(dev));
+			printk(KERN_INFO "%s: receive timeout(%d,%02x)\n",
+			       dev->name, rcv->state, c0);
+		}
+		nl->enet_stats.rx_dropped++;
+	}
+	rcv->state = PLIP_PK_DONE;
+	if (rcv->skb) {
+		kfree_skb(rcv->skb);
+		rcv->skb = NULL;
+	}
+	snd->state = PLIP_PK_DONE;
+	if (snd->skb) {
+		dev_kfree_skb(snd->skb);
+		snd->skb = NULL;
+	}
+	enable_par_irq(dev, 0);
+	dev->tbusy = 1;
+	nl->connection = PLIP_CN_ERROR;
+	z_writeb(0x00, PAR_DATA(dev));
+	local_irq_restore(flags);
+
+	return TIMEOUT;
+}
+
+static int
+plip_none(struct device *dev, struct net_local *nl,
+	  struct plip_local *snd, struct plip_local *rcv)
+{
+	return OK;
+}
+
+/* PLIP_RECEIVE --- receive a byte(two nibbles)
+   Returns OK on success, TIMEOUT on timeout */
+inline static int
+plip_receive(struct device *dev, unsigned short nibble_timeout, 
+	     enum plip_nibble_state *ns_p, unsigned char *data_p)
+{
+	unsigned char c0, c1;
+	unsigned int cx;
+
+	switch (*ns_p) {
+	case PLIP_NB_BEGIN:
+		cx = nibble_timeout;
+		while (1) {
+			c0 = z_readb(PAR_STATUS(dev));
+			udelay(PLIP_DELAY_UNIT);
+			if ((c0 & 0x80) == 0) {
+				c1 = z_readb(PAR_STATUS(dev));
+				if (c0 == c1)
+					break;
+			}
+			if (--cx == 0)
+				return TIMEOUT;
+		}
+#if 0
+		printk("received first nybble: %02X -> %02X\n",
+		       c0, (c0 >> 3) & 0x0F);
+#endif
+		*data_p = (c0 >> 3) & 0x0f;
+		z_writeb(0x10, PAR_DATA(dev)); /* send ACK */
+		*ns_p = PLIP_NB_1;
+
+	case PLIP_NB_1:
+		cx = nibble_timeout;
+		while (1) {
+			c0 = z_readb(PAR_STATUS(dev));
+			udelay(PLIP_DELAY_UNIT);
+			if (c0 & 0x80) {
+				c1 = z_readb(PAR_STATUS(dev));
+				if (c0 == c1)
+					break;
+			}
+			if (--cx == 0)
+				return TIMEOUT;
+		}
+#if 0
+		printk("received second nybble: %02X -> %02X\n",
+		       c0, (c0 << 1) & 0xF0);
+#endif
+		*data_p |= (c0 << 1) & 0xf0;
+		z_writeb(0x00, PAR_DATA(dev)); /* send ACK */
+		*ns_p = PLIP_NB_BEGIN;
+	case PLIP_NB_2:
+		break;
+	}
+	return OK;
+}
+
+/* PLIP_RECEIVE_PACKET --- receive a packet */
+static int
+plip_receive_packet(struct device *dev, struct net_local *nl,
+		    struct plip_local *snd, struct plip_local *rcv)
+{
+	unsigned short nibble_timeout = nl->nibble;
+	unsigned char *lbuf;
+	unsigned long flags;
+
+	switch (rcv->state) {
+	case PLIP_PK_TRIGGER:
+		enable_par_irq(dev, 0);
+		dev->interrupt = 0;
+		z_writeb(0x01, PAR_DATA(dev)); /* send ACK */
+		if (net_debug > 2)
+			printk(KERN_DEBUG "%s: receive start\n", dev->name);
+		rcv->state = PLIP_PK_LENGTH_LSB;
+		rcv->nibble = PLIP_NB_BEGIN;
+
+	case PLIP_PK_LENGTH_LSB:
+		if (snd->state != PLIP_PK_DONE) {
+			if (plip_receive(dev, nl->trigger,
+					 &rcv->nibble, &rcv->length.b.lsb)) {
+				/* collision, here dev->tbusy == 1 */
+				rcv->state = PLIP_PK_DONE;
+				nl->is_deferred = 1;
+				nl->connection = PLIP_CN_SEND;
+				queue_task(&nl->deferred, &tq_timer);
+				enable_par_irq(dev, 1);
+				return OK;
+			}
+		} else {
+			if (plip_receive(dev, nibble_timeout, 
+					 &rcv->nibble, &rcv->length.b.lsb))
+				return TIMEOUT;
+		}
+		rcv->state = PLIP_PK_LENGTH_MSB;
+
+	case PLIP_PK_LENGTH_MSB:
+		if (plip_receive(dev, nibble_timeout, 
+				 &rcv->nibble, &rcv->length.b.msb))
+			return TIMEOUT;
+		if (rcv->length.h > dev->mtu + dev->hard_header_len
+		    || rcv->length.h < 8) {
+			printk(KERN_INFO "%s: bogus packet size %d.\n",
+			       dev->name, rcv->length.h);
+			return ERROR;
+		}
+		/* Malloc up new buffer. */
+		rcv->skb = dev_alloc_skb(rcv->length.h);
+		if (rcv->skb == NULL) {
+			printk(KERN_INFO "%s: Memory squeeze.\n", dev->name);
+			return ERROR;
+		}
+		skb_put(rcv->skb,rcv->length.h);
+		rcv->skb->dev = dev;
+		rcv->state = PLIP_PK_DATA;
+		rcv->byte = 0;
+		rcv->checksum = 0;
+
+	case PLIP_PK_DATA:
+		lbuf = rcv->skb->data;
+		do
+			if (plip_receive(dev, nibble_timeout, 
+					 &rcv->nibble, &lbuf[rcv->byte]))
+				return TIMEOUT;
+		while (++rcv->byte < rcv->length.h);
+		do
+			rcv->checksum += lbuf[--rcv->byte];
+		while (rcv->byte);
+		rcv->state = PLIP_PK_CHECKSUM;
+
+	case PLIP_PK_CHECKSUM:
+		if (plip_receive(dev, nibble_timeout, 
+				 &rcv->nibble, &rcv->data))
+			return TIMEOUT;
+		if (rcv->data != rcv->checksum) {
+			nl->enet_stats.rx_crc_errors++;
+			if (net_debug)
+				printk(KERN_INFO "%s: checksum error\n",
+				       dev->name);
+			return ERROR;
+		}
+		rcv->state = PLIP_PK_DONE;
+
+	case PLIP_PK_DONE:
+		/* Inform the upper layer for the arrival of a packet. */
+		rcv->skb->protocol=eth_type_trans(rcv->skb, dev);
+		netif_rx(rcv->skb);
+		nl->enet_stats.rx_packets++;
+		rcv->skb = NULL;
+		if (net_debug > 2)
+			printk(KERN_DEBUG "%s: receive end\n", dev->name);
+
+		/* Close the connection. */
+		z_writeb (0x00, PAR_DATA(dev));
+
+		local_irq_save(flags);
+		if (snd->state != PLIP_PK_DONE) {
+			nl->connection = PLIP_CN_SEND;
+			local_irq_restore(flags);
+			queue_task(&nl->immediate, &tq_immediate);
+			mark_bh(IMMEDIATE_BH);
+			enable_par_irq(dev, 1);
+			return OK;
+		} else {
+			nl->connection = PLIP_CN_NONE;
+			local_irq_restore(flags);
+			enable_par_irq(dev, 1);
+			return OK;
+		}
+	}
+	return OK;
+}
+
+/* PLIP_SEND --- send a byte (two nibbles) 
+   Returns OK on success, TIMEOUT when timeout    */
+inline static int
+plip_send(struct device *dev, unsigned short nibble_timeout, 
+	  enum plip_nibble_state *ns_p, unsigned char data)
+{
+	unsigned char c0;
+	unsigned int cx;
+
+	switch (*ns_p) {
+	case PLIP_NB_BEGIN:
+		z_writeb((data & 0x0f), PAR_DATA(dev));
+		*ns_p = PLIP_NB_1;
+
+	case PLIP_NB_1:
+		z_writeb(0x10 | (data & 0x0f), PAR_DATA(dev));
+		cx = nibble_timeout;
+		while (1) {
+			c0 = z_readb(PAR_STATUS(dev));
+			if ((c0 & 0x80) == 0) 
+				break;
+			if (--cx == 0)
+				return TIMEOUT;
+			udelay(PLIP_DELAY_UNIT);
+		}
+		z_writeb(0x10 | (data >> 4), PAR_DATA(dev));
+		*ns_p = PLIP_NB_2;
+
+	case PLIP_NB_2:
+		z_writeb((data >> 4), PAR_DATA(dev));
+		cx = nibble_timeout;
+		while (1) {
+			c0 = z_readb(PAR_STATUS(dev));
+			if (c0 & 0x80)
+				break;
+			if (--cx == 0)
+				return TIMEOUT;
+			udelay(PLIP_DELAY_UNIT);
+		}
+		*ns_p = PLIP_NB_BEGIN;
+		return OK;
+	}
+	return OK;
+}
+
+/* PLIP_SEND_PACKET --- send a packet */
+static int
+plip_send_packet(struct device *dev, struct net_local *nl,
+		 struct plip_local *snd, struct plip_local *rcv)
+{
+	unsigned short nibble_timeout = nl->nibble;
+	unsigned char *lbuf;
+	unsigned char c0;
+	unsigned int cx;
+	unsigned long flags;
+
+	if (snd->skb == NULL || (lbuf = snd->skb->data) == NULL) {
+		printk(KERN_INFO "%s: send skb lost\n", dev->name);
+		snd->state = PLIP_PK_DONE;
+		snd->skb = NULL;
+		return ERROR;
+	}
+
+	if (snd->length.h == 0) {
+		return OK;
+	}
+
+	switch (snd->state) {
+	case PLIP_PK_TRIGGER:
+		if ((z_readb(PAR_STATUS(dev)) & 0xf8) != 0x80)
+			return TIMEOUT;
+
+		/* Trigger remote rx interrupt. */
+		z_writeb(0x08, PAR_DATA(dev));
+		cx = nl->trigger;
+		while (1) {
+			udelay(PLIP_DELAY_UNIT);
+                        local_irq_save(flags);
+			if (nl->connection == PLIP_CN_RECEIVE) {
+				local_irq_restore(flags);
+				/* interrupted */
+				nl->enet_stats.collisions++;
+				if (net_debug > 1)
+					printk(KERN_INFO "%s: collision.\n",
+					       dev->name);
+				return OK;
+			}
+			c0 = z_readb(PAR_STATUS(dev));
+			if (c0 & 0x08) {
+				enable_par_irq(dev, 0);
+				if (net_debug > 2)
+					printk(KERN_DEBUG "%s: send start\n",
+					       dev->name);
+				snd->state = PLIP_PK_LENGTH_LSB;
+				snd->nibble = PLIP_NB_BEGIN;
+				nl->timeout_count = 0;
+				local_irq_restore(flags);
+				break;
+			}
+			local_irq_restore(flags);
+			if (--cx == 0) {
+				z_writeb(0x00, PAR_DATA(dev));
+				return TIMEOUT;
+			}
+		}
+
+	case PLIP_PK_LENGTH_LSB:
+		if (plip_send(dev, nibble_timeout, 
+			      &snd->nibble, snd->length.b.lsb))
+			return TIMEOUT;
+		snd->state = PLIP_PK_LENGTH_MSB;
+
+	case PLIP_PK_LENGTH_MSB:
+		if (plip_send(dev, nibble_timeout, 
+			      &snd->nibble, snd->length.b.msb))
+			return TIMEOUT;
+		snd->state = PLIP_PK_DATA;
+		snd->byte = 0;
+		snd->checksum = 0;
+
+	case PLIP_PK_DATA:
+		do
+			if (plip_send(dev, nibble_timeout, 
+				      &snd->nibble, lbuf[snd->byte]))
+				return TIMEOUT;
+		while (++snd->byte < snd->length.h);
+		do
+			snd->checksum += lbuf[--snd->byte];
+		while (snd->byte);
+		snd->state = PLIP_PK_CHECKSUM;
+
+	case PLIP_PK_CHECKSUM:
+		if (plip_send(dev, nibble_timeout, 
+			      &snd->nibble, snd->checksum))
+			return TIMEOUT;
+
+		dev_kfree_skb(snd->skb);
+		nl->enet_stats.tx_packets++;
+		snd->state = PLIP_PK_DONE;
+
+	case PLIP_PK_DONE:
+		/* Close the connection */
+		z_writeb (0x00, PAR_DATA(dev));
+		snd->skb = NULL;
+		if (net_debug > 2)
+			printk(KERN_DEBUG "%s: send end\n", dev->name);
+		nl->connection = PLIP_CN_CLOSING;
+		nl->is_deferred = 1;
+		queue_task(&nl->deferred, &tq_timer);
+		enable_par_irq(dev, 1);
+		return OK;
+	}
+	return OK;
+}
+
+static int
+plip_connection_close(struct device *dev, struct net_local *nl,
+		      struct plip_local *snd, struct plip_local *rcv)
+{
+	unsigned long flags;
+
+        local_irq_save(flags);
+	if (nl->connection == PLIP_CN_CLOSING) {
+		nl->connection = PLIP_CN_NONE;
+		dev->tbusy = 0;
+		mark_bh(NET_BH);
+	}
+	local_irq_restore(flags);
+	return OK;
+}
+
+/* PLIP_ERROR --- wait till other end settled */
+static int
+plip_error(struct device *dev, struct net_local *nl,
+	   struct plip_local *snd, struct plip_local *rcv)
+{
+	unsigned char status;
+
+	status = z_readb(PAR_STATUS(dev));
+	if ((status & 0xf8) == 0x80) {
+		if (net_debug > 2)
+			printk(KERN_DEBUG "%s: reset interface.\n", dev->name);
+		nl->connection = PLIP_CN_NONE;
+		dev->tbusy = 0;
+		dev->interrupt = 0;
+		enable_par_irq(dev, 1);
+		mark_bh(NET_BH);
+	} else {
+		nl->is_deferred = 1;
+		queue_task(&nl->deferred, &tq_timer);
+	}
+
+	return OK;
+}
+
+/* We don't need to send arp, for plip is point-to-point. */
+static int
+plip_rebuild_header(struct sk_buff *skb)
+{
+	struct device *dev = skb->dev;
+	struct net_local *nl = (struct net_local *)dev->priv;
+	struct ethhdr *eth = (struct ethhdr *)skb->data;
+	int i;
+
+	if ((dev->flags & IFF_NOARP)==0)
+		return nl->orig_rebuild_header(skb);
+
+	if (eth->h_proto != __constant_htons(ETH_P_IP)
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+	    && eth->h_proto != __constant_htons(ETH_P_IPV6)
+#endif
+		) {
+		printk(KERN_ERR "plip_rebuild_header: Don't know how to resolve type %d addresses?\n", (int)eth->h_proto);
+		memcpy(eth->h_source, dev->dev_addr, dev->addr_len);
+		return 0;
+	}
+
+	for (i=0; i < ETH_ALEN - sizeof(u32); i++)
+		eth->h_dest[i] = 0xfc;
+#if 0
+	*(u32 *)(eth->h_dest+i) = dst;
+#else
+	/* Do not want to include net/route.h here.
+	 * In any case, it is TOP of silliness to emulate
+	 * hardware addresses on PtP link. --ANK
+	 */
+	*(u32 *)(eth->h_dest+i) = 0;
+#endif
+	return 0;
+}
+
+static int
+plip_tx_packet(struct sk_buff *skb, struct device *dev)
+{
+	struct net_local *nl = (struct net_local *)dev->priv;
+	struct plip_local *snd = &nl->snd_data;
+	unsigned long flags;
+
+	if (dev->tbusy)
+		return 1;
+
+	if (test_and_set_bit(0, (void*)&dev->tbusy) != 0) {
+		printk(KERN_ERR "%s: Transmitter access conflict.\n",
+		       dev->name);
+		return 1;
+	}
+
+	if (skb->len > dev->mtu + dev->hard_header_len) {
+		printk(KERN_ERR "%s: packet too big, %d.\n",
+		       dev->name, (int)skb->len);
+		dev->tbusy = 0;
+		return 0;
+	}
+
+	if (net_debug > 2)
+		printk(KERN_DEBUG "%s: send request\n", dev->name);
+
+	local_irq_save(flags);
+	dev->trans_start = jiffies;
+	snd->skb = skb;
+	snd->length.h = skb->len;
+	snd->state = PLIP_PK_TRIGGER;
+	if (nl->connection == PLIP_CN_NONE) {
+		nl->connection = PLIP_CN_SEND;
+		nl->timeout_count = 0;
+	}
+	queue_task(&nl->immediate, &tq_immediate);
+	mark_bh(IMMEDIATE_BH);
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+/* Open/initialize the board.  This is called (in the current kernel)
+   sometime after booting when the 'ifconfig' program is run.
+
+ */
+static int
+plip_open(struct device *dev)
+{
+	struct net_local *nl = (struct net_local *)dev->priv;
+	struct in_device *in_dev;
+
+#if defined(CONFIG_GVPIOEXT_LP) || defined(CONFIG_GVPIOEXT_LP_MODULE)
+	/* Yes, there is a race condition here. Fix it later */
+	if (PLIP_DEV(dev)->par_use & IOEXT_PAR_LP) {
+		/* Can't open if lp is in use */
+#if DEBUG
+		printk("par is in use by lp\n");
+#endif
+		return(-EBUSY);
+	}
+#endif
+	PLIP_DEV(dev)->par_use |= IOEXT_PAR_PLIP;
+
+#if DEBUG
+	printk("plip_open(): sending 00 to data port\n");
+#endif
+
+	/* Clear the data port. */
+	z_writeb (0x00, PAR_DATA(dev));
+
+#if DEBUG
+	printk("plip_open(): sent\n");
+#endif
+
+	/* Initialize the state machine. */
+	nl->rcv_data.state = nl->snd_data.state = PLIP_PK_DONE;
+	nl->rcv_data.skb = nl->snd_data.skb = NULL;
+	nl->connection = PLIP_CN_NONE;
+	nl->is_deferred = 0;
+
+	/* Fill in the MAC-level header.
+	   (ab)Use "dev->broadcast" to store point-to-point MAC address.
+
+	   PLIP doesn't have a real mac address, but we need to create one
+	   to be DOS compatible.  */
+	memset(dev->dev_addr,  0xfc, ETH_ALEN);
+	memset(dev->broadcast, 0xfc, ETH_ALEN);
+
+	if ((in_dev=dev->ip_ptr) != NULL) {
+		/*
+		 *	Any address will do - we take the first
+		 */
+		struct in_ifaddr *ifa=in_dev->ifa_list;
+		if (ifa != NULL) {
+			memcpy(dev->dev_addr+2, &ifa->ifa_local, 4);
+			memcpy(dev->broadcast+2, &ifa->ifa_address, 4);
+		}
+	}
+
+	dev->interrupt = 0;
+	dev->start = 1;
+	dev->tbusy = 0;
+
+	MOD_INC_USE_COUNT;
+
+	/* Enable rx interrupt. */
+	enable_par_irq(dev, 1);
+
+	return 0;
+}
+
+/* The inverse routine to plip_open (). */
+static int
+plip_close(struct device *dev)
+{
+	struct net_local *nl = (struct net_local *)dev->priv;
+	struct plip_local *snd = &nl->snd_data;
+	struct plip_local *rcv = &nl->rcv_data;
+	unsigned long flags;
+
+	dev->tbusy = 1;
+	dev->start = 0;
+        local_irq_save(flags);
+	nl->is_deferred = 0;
+	nl->connection = PLIP_CN_NONE;
+	local_irq_restore(flags);
+	z_writeb(0x00, PAR_DATA(dev));
+
+	snd->state = PLIP_PK_DONE;
+	if (snd->skb) {
+		dev_kfree_skb(snd->skb);
+		snd->skb = NULL;
+	}
+	rcv->state = PLIP_PK_DONE;
+	if (rcv->skb) {
+		kfree_skb(rcv->skb);
+		rcv->skb = NULL;
+	}
+
+	PLIP_DEV(dev)->par_use &= ~IOEXT_PAR_PLIP;
+
+	MOD_DEC_USE_COUNT;
+	return 0;
+}
+
+static struct enet_statistics *
+plip_get_stats(struct device *dev)
+{
+	struct net_local *nl = (struct net_local *)dev->priv;
+	struct enet_statistics *r = &nl->enet_stats;
+
+	return r;
+}
+
+static int
+plip_config(struct device *dev, struct ifmap *map)
+{
+	if (dev->flags & IFF_UP)
+		return -EBUSY;
+
+	printk(KERN_INFO "%s: This interface is autodetected (ignored).\n",
+	       dev->name);
+
+	return 0;
+}
+
+static int
+plip_ioctl(struct device *dev, struct ifreq *rq, int cmd)
+{
+	struct net_local *nl = (struct net_local *) dev->priv;
+	struct plipconf *pc = (struct plipconf *) &rq->ifr_data;
+  
+	switch(pc->pcmd) {
+	case PLIP_GET_TIMEOUT:
+		pc->trigger = nl->trigger;
+		pc->nibble  = nl->nibble;
+		break;
+	case PLIP_SET_TIMEOUT:
+		nl->trigger = pc->trigger;
+		nl->nibble  = pc->nibble;
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+	return 0;
+}
+
+/*
+ * Detect and initialize all IO-Extenders in this system.
+ *
+ * Both PLIP and serial devices are configured.
+ */
+int plip_init(struct device *dev)
+{
+	IOEXT_struct *board;
+	struct net_local *nl;
+
+	if (ioext_num == 0) {
+		printk(KERN_INFO "%s\n", version);
+	}
+
+	board = PLIP_DEV(dev)->board;
+	dev->base_addr = (unsigned long)&board->par.DATA;
+
+	/* Cheat and use irq to index into our table */
+	dev->irq = ioext_num;
+
+	printk(KERN_INFO "%s: IO-Extender parallel port at 0x%08lX\n", dev->name, dev->base_addr);
+
+	/* Fill in the generic fields of the device structure. */
+	ether_setup(dev);
+
+	/* Then, override parts of it */
+	dev->hard_start_xmit  = plip_tx_packet;
+	dev->open    = plip_open;
+	dev->stop    = plip_close;
+	dev->get_stats     = plip_get_stats;
+	dev->set_config    = plip_config;
+	dev->do_ioctl    = plip_ioctl;
+	dev->tx_queue_len  = 10;
+	dev->flags          = IFF_POINTOPOINT|IFF_NOARP;
+
+	/* Set the private structure */
+	dev->priv = kmalloc(sizeof (struct net_local), GFP_KERNEL);
+	if (dev->priv == NULL) {
+		printk(KERN_ERR "%s: out of memory\n", dev->name);
+		return -ENOMEM;
+	}
+	memset(dev->priv, 0, sizeof(struct net_local));
+	nl = (struct net_local *) dev->priv;
+
+	nl->orig_rebuild_header = dev->rebuild_header;
+	dev->rebuild_header   = plip_rebuild_header;
+
+	/* Initialize constants */
+	nl->trigger  = PLIP_TRIGGER_WAIT;
+	nl->nibble  = PLIP_NIBBLE_WAIT;
+
+	/* Initialize task queue structures */
+	nl->immediate.next = NULL;
+	nl->immediate.sync = 0;
+	nl->immediate.routine = (void *)(void *)plip_bh;
+	nl->immediate.data = dev;
+
+	nl->deferred.next = NULL;
+	nl->deferred.sync = 0;
+	nl->deferred.routine = (void *)(void *)plip_kick_bh;
+	nl->deferred.data = dev;
+
+	/* Don't enable interrupts yet */
+
+	return 0;
+}
diff -Naur linux-2.6.8.1/drivers/dio/dio.c linux-2.6.8.1-m68k-20040817/drivers/dio/dio.c
--- linux-2.6.8.1/drivers/dio/dio.c	2004-08-14 20:55:48.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/drivers/dio/dio.c	2004-07-16 06:07:30.000000000 +1000
@@ -1,4 +1,4 @@
-/* Code to support devices on the DIO (and eventually DIO-II) bus
+/* Code to support devices on the DIO and DIO-II bus
  * Copyright (C) 05/1998 Peter Maydell <pmaydell@chiark.greenend.org.uk>
  * 
  * This code has basically these routines at the moment:
@@ -9,9 +9,8 @@
  *    This means that framebuffers should pass it as 
  *    DIO_ENCODE_ID(DIO_ID_FBUFFER,DIO_ID2_TOPCAT)
  *    (or whatever); everybody else just uses DIO_ID_FOOBAR.
- * void *dio_scodetoviraddr(int scode)
- *    Return the virtual address corresponding to the given select code.
- *    NB: DIO-II devices will have to be mapped in in this routine!
+ * unsigned long dio_scodetophysaddr(int scode)
+ *    Return the physical address corresponding to the given select code.
  * int dio_scodetoipl(int scode)
  *    Every DIO card has a fixed interrupt priority level. This function 
  *    returns it, whatever it is.
@@ -30,8 +29,9 @@
 #include <linux/dio.h>
 #include <linux/slab.h>                         /* kmalloc() */
 #include <linux/init.h>
-#include <asm/hwtest.h>                           /* hwreg_present() */
-#include <asm/io.h>                               /* readb() */
+#include <asm/uaccess.h>
+#include <asm/io.h>                             /* readb() */
+
 /* not a real config option yet! */
 #define CONFIG_DIO_CONSTANTS
 
@@ -59,7 +59,7 @@
         DIONAME(DCA0), DIONAME(DCA0REM), DIONAME(DCA1), DIONAME(DCA1REM),
         DIONAME(DCM), DIONAME(DCMREM),
         DIONAME(LAN),
-        DIONAME(FHPIB), DIONAME(NHPIB), DIONAME(IHPIB),
+        DIONAME(FHPIB), DIONAME(NHPIB),
         DIONAME(SCSI0), DIONAME(SCSI1), DIONAME(SCSI2), DIONAME(SCSI3),
         DIONAME(FBUFFER),
         DIONAME(PARALLEL), DIONAME(VME), DIONAME(DCL), DIONAME(DCLREM),
@@ -79,7 +79,7 @@
 #define NUMNAMES (sizeof(names) / sizeof(struct dioname))
 
 static const char *unknowndioname 
-        = "unknown DIO board -- please email <pmaydell@chiark.greenend.org.uk>!";
+        = "unknown DIO board -- please email <linux-m68k@lists.linux-m68k.org>!";
 
 static const char *dio_getname(int id)
 {
@@ -88,7 +88,7 @@
         for (i = 0; i < NUMNAMES; i++)
                 if (names[i].id == id) 
                         return names[i].name;
-        
+
         return unknowndioname;
 }
 
@@ -115,54 +115,78 @@
 static int __init dio_find_slow(int deviceid)
 {
 	/* Called to find a DIO device before the full bus scan has run.  Basically
-         * only used by the console driver.
-         * We don't do the primary+secondary ID encoding thing here. Maybe we should.
-         * (that would break the topcat detection, though. I need to think about
-         * the whole primary/secondary ID thing.)
-         */
-	int scode;
-        u_char prid;
+	 * only used by the console driver.
+	 */
+	int scode, id;
+	u_char prid, secid, i;
+	mm_segment_t fs;
 
 	for (scode = 0; scode < DIO_SCMAX; scode++)
 	{
 		void *va;
+		unsigned long pa;
 
                 if (DIO_SCINHOLE(scode))
                         continue;
-                
-                va = dio_scodetoviraddr(scode);
-                if (!va || !hwreg_present(va + DIO_IDOFF))
+
+                pa = dio_scodetophysaddr(scode);
+
+		if (!pa)
+			continue;
+
+		if (scode < DIOII_SCBASE)
+			va = (void *)(pa + DIO_VIRADDRBASE);
+		else
+			va = ioremap(pa, PAGE_SIZE);
+
+		fs = get_fs();
+		set_fs(KERNEL_DS);
+
+                if (get_user(i, (unsigned char *)va + DIO_IDOFF))
+		{
+			set_fs(fs);
+			if (scode >= DIOII_SCBASE)
+				iounmap(va);
                         continue;             /* no board present at that select code */
+		}
+
+		set_fs(fs);
+		prid = DIO_ID(va);
 
-                /* We aren't very likely to want to use this to get at the IHPIB,
-                 * but maybe it's returning the same ID as the card we do want...
-                 */
-                if (!DIO_ISIHPIB(scode))
-                        prid = DIO_ID(va);
+                if (DIO_NEEDSSECID(prid))
+                {
+                        secid = DIO_SECID(va);
+                        id = DIO_ENCODE_ID(prid, secid);
+                }
                 else
-                        prid = DIO_ID_IHPIB;
+			id = prid;
 
-		if (prid == deviceid)
+		if (id == deviceid)
+		{
+			if (scode >= DIOII_SCBASE)
+				iounmap(va);
 			return scode;
+		}
 	}
-	return 0;
+
+	return -1;
 }
 
-/* Aargh: we use 0 for an error return code, but select code 0 exists!
- * FIXME (trivial, use -1, but requires changes to all the drivers :-< )
- */
 int dio_find(int deviceid)
 {
-	if (blist) 
+	if (blist)
 	{
 		/* fast way */
 		struct dioboard *b;
 		for (b = blist; b; b = b->next)
 			if (b->id == deviceid && b->configured == 0)
 				return b->scode;
-		return 0;
+		return -1;
+	}
+	else
+	{
+		return dio_find_slow(deviceid);
 	}
-	return dio_find_slow(deviceid);
 }
 
 /* This is the function that scans the DIO space and works out what
@@ -170,34 +194,51 @@
  */
 static int __init dio_init(void)
 {
-        int scode;
-        struct dioboard *b, *bprev = NULL;
+	int scode;
+	struct dioboard *b, *bprev = NULL;
+	mm_segment_t fs;
+	char i;
    
-        printk("Scanning for DIO devices...\n");
+        printk(KERN_INFO "Scanning for DIO devices...\n");
         
         for (scode = 0; scode < DIO_SCMAX; ++scode)
         {
                 u_char prid, secid = 0;        /* primary, secondary ID bytes */
                 u_char *va;
+		unsigned long pa;
                 
                 if (DIO_SCINHOLE(scode))
                         continue;
-                
-                va = dio_scodetoviraddr(scode);
-                if (!va || !hwreg_present(va + DIO_IDOFF))
+
+		pa = dio_scodetophysaddr(scode);
+
+		if (!pa)
+			continue;
+
+		if (scode < DIOII_SCBASE)
+			va = (void *)(pa + DIO_VIRADDRBASE);
+		else
+			va = ioremap(pa, PAGE_SIZE);
+
+		fs = get_fs();
+		set_fs(KERNEL_DS);
+
+                if (get_user(i, (unsigned char *)va + DIO_IDOFF))
+		{
+			set_fs(fs);
+			if (scode >= DIOII_SCBASE)
+				iounmap(va);
                         continue;              /* no board present at that select code */
+		}
+
+		set_fs(fs);
 
                 /* Found a board, allocate it an entry in the list */
                 b = kmalloc(sizeof(struct dioboard), GFP_KERNEL);
-                
-                /* read the ID byte(s) and encode if necessary. Note workaround 
-                 * for broken internal HPIB devices...
-                 */
-                if (!DIO_ISIHPIB(scode))
-                        prid = DIO_ID(va);
-                else 
-                        prid = DIO_ID_IHPIB;
-                
+
+                /* read the ID byte(s) and encode if necessary. */
+		prid = DIO_ID(va);
+
                 if (DIO_NEEDSSECID(prid))
                 {
                         secid = DIO_SECID(va);
@@ -205,16 +246,19 @@
                 }
                 else
                         b->id = prid;
-      
+
                 b->configured = 0;
                 b->scode = scode;
                 b->ipl = DIO_IPL(va);
                 b->name = dio_getname(b->id);
-                printk("select code %3d: ipl %d: ID %02X", scode, b->ipl, prid);
-                if (DIO_NEEDSSECID(b->id))
+                printk(KERN_INFO "select code %3d: ipl %d: ID %02X", b->scode, b->ipl, prid);
+                if (DIO_NEEDSSECID(prid))
                         printk(":%02X", secid);
                 printk(": %s\n", b->name);
-                
+
+		if (scode >= DIOII_SCBASE)
+			iounmap(va);
+
                 b->next = NULL;
 
                 if (bprev)
@@ -223,29 +267,27 @@
                         blist = b;
                 bprev = b;
         }
+
 	return 0;
 }
 
 subsys_initcall(dio_init);
 
 /* Bear in mind that this is called in the very early stages of initialisation
- * in order to get the virtual address of the serial port for the console...
+ * in order to get the address of the serial port for the console...
  */
-void *dio_scodetoviraddr(int scode)
+unsigned long dio_scodetophysaddr(int scode)
 {
-        if (scode > DIOII_SCBASE)
+        if (scode >= DIOII_SCBASE)
         {
-                printk("dio_scodetoviraddr: don't support DIO-II yet!\n");
-                return 0;
+                return (DIOII_BASE + (scode - 132) * DIOII_DEVSIZE);
         }
         else if (scode > DIO_SCMAX || scode < 0)
                 return 0;
         else if (DIO_SCINHOLE(scode))
                 return 0;
-        else if (DIO_ISIHPIB(scode))
-                return (void*)DIO_IHPIBADDR;
 
-        return (void*)(DIO_VIRADDRBASE + DIO_BASE + scode * 0x10000);
+        return (DIO_BASE + scode * DIO_DEVSIZE);
 }
 
 int dio_scodetoipl(int scode)
@@ -254,10 +296,10 @@
         for (b = blist; b; b = b->next)
                 if (b->scode == scode) 
                         break;
-        
+
         if (!b)
         {
-                printk("dio_scodetoipl: bad select code %d\n", scode);
+                printk(KERN_ERR "dio_scodetoipl: bad select code %d\n", scode);
                 return 0;
         }
         else
@@ -270,10 +312,10 @@
         for (b = blist; b; b = b->next)
                 if (b->scode == scode) 
                         break;
-        
+
         if (!b)
         {
-                printk("dio_scodetoname: bad select code %d\n", scode);
+                printk(KERN_ERR "dio_scodetoname: bad select code %d\n", scode);
                 return NULL;
         }
         else
@@ -286,11 +328,11 @@
         for (b = blist; b; b = b->next)
                 if (b->scode == scode)
                         break;
-   
+
         if (!b) 
-                printk("dio_config_board: bad select code %d\n", scode);
+                printk(KERN_ERR "dio_config_board: bad select code %d\n", scode);
         else if (b->configured)
-                printk("dio_config_board: board at select code %d already configured\n", scode);
+                printk(KERN_WARNING "dio_config_board: board at select code %d already configured\n", scode);
         else
                 b->configured = 1;
 }
@@ -301,11 +343,11 @@
         for (b = blist; b; b = b->next)
                 if (b->scode == scode) 
                         break;
-   
+
         if (!b) 
-                printk("dio_unconfig_board: bad select code %d\n", scode);
+                printk(KERN_ERR "dio_unconfig_board: bad select code %d\n", scode);
         else if (!b->configured)
-                printk("dio_unconfig_board: board at select code %d not configured\n", 
+                printk(KERN_WARNING "dio_unconfig_board: board at select code %d not configured\n", 
 		       scode);
         else 
                 b->configured = 0;
diff -Naur linux-2.6.8.1/drivers/ide/ide-iops.c linux-2.6.8.1-m68k-20040817/drivers/ide/ide-iops.c
--- linux-2.6.8.1/drivers/ide/ide-iops.c	2004-08-14 20:55:10.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/drivers/ide/ide-iops.c	2004-06-17 07:16:36.000000000 +1000
@@ -359,6 +359,23 @@
 	int i;
 	u16 *stringcast;
 
+#ifdef __mc68000__
+	if (!MACH_IS_AMIGA && !MACH_IS_MAC && !MACH_IS_Q40 && !MACH_IS_ATARI)
+		return;
+
+#ifdef M68K_IDE_SWAPW
+	if (M68K_IDE_SWAPW) {	/* fix bus byteorder first */
+		u_char *p = (u_char *)id;
+		u_char t;
+		for (i = 0; i < 512; i += 2) {
+			t = p[i];
+			p[i] = p[i+1];
+			p[i+1] = t;
+		}
+	}
+#endif
+#endif /* __mc68000__ */
+
 	id->config         = __le16_to_cpu(id->config);
 	id->cyls           = __le16_to_cpu(id->cyls);
 	id->reserved2      = __le16_to_cpu(id->reserved2);
diff -Naur linux-2.6.8.1/drivers/macintosh/adb.c linux-2.6.8.1-m68k-20040817/drivers/macintosh/adb.c
--- linux-2.6.8.1/drivers/macintosh/adb.c	2004-08-14 20:56:24.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/drivers/macintosh/adb.c	2004-08-16 01:24:27.000000000 +1000
@@ -476,13 +476,15 @@
 		use_sreq = 1;
 	} else
 		use_sreq = 0;
-	req->nbytes = nbytes+1;
+	i = (flags & ADBREQ_RAW) ? 0 : 1;
+	req->nbytes = nbytes+i;
 	req->done = done;
 	req->reply_expected = flags & ADBREQ_REPLY;
 	req->data[0] = ADB_PACKET;
 	va_start(list, nbytes);
-	for (i = 0; i < nbytes; ++i)
-		req->data[i+1] = va_arg(list, int);
+	while (i < req->nbytes) {
+		req->data[i++] = va_arg(list, int);
+	}
 	va_end(list);
 
 	if (flags & ADBREQ_NOSEND)
diff -Naur linux-2.6.8.1/drivers/net/7990.c linux-2.6.8.1-m68k-20040817/drivers/net/7990.c
--- linux-2.6.8.1/drivers/net/7990.c	2004-08-14 20:55:48.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/drivers/net/7990.c	2004-07-12 01:30:02.000000000 +1000
@@ -14,7 +14,6 @@
  */
 #include <linux/crc32.h>
 #include <linux/delay.h>
-#include <linux/dio.h>
 #include <linux/errno.h>
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
@@ -30,6 +29,7 @@
 #include <linux/slab.h>
 #include <linux/string.h>
 #include <linux/skbuff.h>
+#include <linux/irq.h>
 /* Used for the temporal inet entries and routing */
 #include <linux/socket.h>
 
@@ -38,18 +38,58 @@
 #include <asm/io.h>
 #include <asm/dma.h>
 #include <asm/pgtable.h>
+#ifdef CONFIG_HP300
+#include <asm/blinken.h>
+#endif
 
 #include "7990.h"
 
+#define WRITERAP(lp,x) out_be16(lp->base + LANCE_RAP, (x))
+#define WRITERDP(lp,x) out_be16(lp->base + LANCE_RDP, (x))
+#define READRDP(lp) in_be16(lp->base + LANCE_RDP)
+
+#if defined(CONFIG_HPLANCE) || defined(CONFIG_HPLANCE_MODULE)
+#include "hplance.h"
+
+#undef WRITERAP
+#undef WRITERDP
+#undef READRDP
+
+#if defined(CONFIG_MVME147_NET) || defined(CONFIG_MVME147_NET_MODULE)
+
 /* Lossage Factor Nine, Mr Sulu. */
-#define WRITERAP(x) (lp->writerap(lp,x))
-#define WRITERDP(x) (lp->writerdp(lp,x))
-#define READRDP() (lp->readrdp(lp))
-/* These used to be ll->rap = x, ll->rdp = x, and (ll->rdp). Sigh. 
- * If you want to switch them back then 
- * #define DECLARE_LL volatile struct lance_regs *ll = lp->ll
- */
-#define DECLARE_LL /* nothing to declare */
+#define WRITERAP(lp,x) (lp->writerap(lp,x))
+#define WRITERDP(lp,x) (lp->writerdp(lp,x))
+#define READRDP(lp) (lp->readrdp(lp))
+
+#else
+
+/* These inlines can be used if only CONFIG_HPLANCE is defined */
+static inline void WRITERAP(struct lance_private *lp, __u16 value)
+{
+	do {
+		out_be16(lp->base + HPLANCE_REGOFF + LANCE_RAP, value);
+	} while ((in_8(lp->base + HPLANCE_STATUS) & LE_ACK) == 0);
+}
+
+static inline void WRITERDP(struct lance_private *lp, __u16 value)
+{
+	do {
+		out_be16(lp->base + HPLANCE_REGOFF + LANCE_RDP, value);
+	} while ((in_8(lp->base + HPLANCE_STATUS) & LE_ACK) == 0);
+}
+
+static inline __u16 READRDP(struct lance_private *lp)
+{
+	__u16 value;
+	do {
+		value = in_be16(lp->base + HPLANCE_REGOFF + LANCE_RDP);
+	} while ((in_8(lp->base + HPLANCE_STATUS) & LE_ACK) == 0);
+	return value;
+}
+
+#endif
+#endif /* CONFIG_HPLANCE || CONFIG_HPLANCE_MODULE */
 
 /* debugging output macros, various flavours */
 /* #define TEST_HITS */
@@ -79,19 +119,18 @@
 {
         volatile struct lance_init_block *aib = lp->lance_init_block;
         int leptr;
-        DECLARE_LL;
 
         leptr = LANCE_ADDR (aib);
 
-        WRITERAP(LE_CSR1);                        /* load address of init block */
-        WRITERDP(leptr & 0xFFFF);
-        WRITERAP(LE_CSR2);
-        WRITERDP(leptr >> 16);
-        WRITERAP(LE_CSR3);
-        WRITERDP(lp->busmaster_regval);           /* set byteswap/ALEctrl/byte ctrl */
+        WRITERAP(lp, LE_CSR1);                    /* load address of init block */
+        WRITERDP(lp, leptr & 0xFFFF);
+        WRITERAP(lp, LE_CSR2);
+        WRITERDP(lp, leptr >> 16);
+        WRITERAP(lp, LE_CSR3);
+        WRITERDP(lp, lp->busmaster_regval);       /* set byteswap/ALEctrl/byte ctrl */
 
         /* Point back to csr0 */
-        WRITERAP(LE_CSR0);
+        WRITERAP(lp, LE_CSR0);
 }
 
 /* #define to 0 or 1 appropriately */
@@ -192,24 +231,23 @@
 static int init_restart_lance (struct lance_private *lp)
 {
         int i;
-        DECLARE_LL;
 
-        WRITERAP(LE_CSR0);
-        WRITERDP(LE_C0_INIT);
+        WRITERAP(lp, LE_CSR0);
+        WRITERDP(lp, LE_C0_INIT);
 
         /* Need a hook here for sunlance ledma stuff */
 
         /* Wait for the lance to complete initialization */
-        for (i = 0; (i < 100) && !(READRDP() & (LE_C0_ERR | LE_C0_IDON)); i++)
+        for (i = 0; (i < 100) && !(READRDP(lp) & (LE_C0_ERR | LE_C0_IDON)); i++)
                 barrier();
-        if ((i == 100) || (READRDP() & LE_C0_ERR)) {
-                printk ("LANCE unopened after %d ticks, csr0=%4.4x.\n", i, READRDP());
+        if ((i == 100) || (READRDP(lp) & LE_C0_ERR)) {
+                printk ("LANCE unopened after %d ticks, csr0=%4.4x.\n", i, READRDP(lp));
                 return -1;
         }
 
         /* Clear IDON by writing a "1", enable interrupts and start lance */
-        WRITERDP(LE_C0_IDON);
-        WRITERDP(LE_C0_INEA | LE_C0_STRT);
+        WRITERDP(lp, LE_C0_IDON);
+        WRITERDP(lp, LE_C0_INEA | LE_C0_STRT);
 
         return 0;
 }
@@ -218,11 +256,10 @@
 {
         struct lance_private *lp = netdev_priv(dev);
         int status;
-        DECLARE_LL;
     
         /* Stop the lance */
-        WRITERAP(LE_CSR0);
-        WRITERDP(LE_C0_STOP);
+        WRITERAP(lp, LE_CSR0);
+        WRITERDP(lp, LE_C0_STOP);
 
         load_csrs (lp);
         lance_init_ring (dev);
@@ -245,7 +282,6 @@
 #ifdef TEST_HITS
         int i;
 #endif
-        DECLARE_LL;
 
 #ifdef TEST_HITS
         printk ("[");
@@ -259,8 +295,10 @@
         }
         printk ("]");
 #endif
-    
-        WRITERDP(LE_C0_RINT | LE_C0_INEA);     /* ack Rx int, reenable ints */
+#ifdef CONFIG_HP300
+	blinken_leds(0x40, 0);
+#endif    
+        WRITERDP(lp, LE_C0_RINT | LE_C0_INEA);     /* ack Rx int, reenable ints */
         for (rd = &ib->brx_ring [lp->rx_new];     /* For each Rx ring we own... */
              !((bits = rd->rmd1_bits) & LE_R1_OWN);
              rd = &ib->brx_ring [lp->rx_new]) {
@@ -321,10 +359,12 @@
         volatile struct lance_tx_desc *td;
         int i, j;
         int status;
-        DECLARE_LL;
 
+#ifdef CONFIG_HP300
+	blinken_leds(0x80, 0);
+#endif
         /* csr0 is 2f3 */
-        WRITERDP(LE_C0_TINT | LE_C0_INEA);
+        WRITERDP(lp, LE_C0_TINT | LE_C0_INEA);
         /* csr0 is 73 */
 
         j = lp->tx_old;
@@ -349,8 +389,8 @@
                                         printk("%s: Carrier Lost, trying %s\n",
                                                dev->name, lp->tpe?"TPE":"AUI");
                                         /* Stop the lance */
-                                        WRITERAP(LE_CSR0);
-                                        WRITERDP(LE_C0_STOP);
+                                        WRITERAP(lp, LE_CSR0);
+                                        WRITERDP(lp, LE_C0_STOP);
                                         lance_init_ring (dev);
                                         load_csrs (lp);
                                         init_restart_lance (lp);
@@ -366,8 +406,8 @@
                                 printk ("%s: Tx: ERR_BUF|ERR_UFL, restarting\n",
                                         dev->name);
                                 /* Stop the lance */
-                                WRITERAP(LE_CSR0);
-                                WRITERDP(LE_C0_STOP);
+                                WRITERAP(lp, LE_CSR0);
+                                WRITERDP(lp, LE_C0_STOP);
                                 lance_init_ring (dev);
                                 load_csrs (lp);
                                 init_restart_lance (lp);
@@ -393,7 +433,7 @@
                 j = (j + 1) & lp->tx_ring_mod_mask;
         }
         lp->tx_old = j;
-        WRITERDP(LE_C0_TINT | LE_C0_INEA);
+        WRITERDP(lp, LE_C0_TINT | LE_C0_INEA);
         return 0;
 }
 
@@ -403,26 +443,25 @@
         struct net_device *dev = (struct net_device *)dev_id;
         struct lance_private *lp = netdev_priv(dev);
         int csr0;
-        DECLARE_LL;
 
 	spin_lock (&lp->devlock);
 
-        WRITERAP(LE_CSR0);              /* LANCE Controller Status */
-        csr0 = READRDP();
+        WRITERAP(lp, LE_CSR0);              /* LANCE Controller Status */
+        csr0 = READRDP(lp);
 
         PRINT_RINGS();
         
         if (!(csr0 & LE_C0_INTR)) {     /* Check if any interrupt has */
-		spin_lock (&lp->devlock);
+		spin_unlock (&lp->devlock);
                 return IRQ_NONE;        /* been generated by the Lance. */
 	}
 
         /* Acknowledge all the interrupt sources ASAP */
-        WRITERDP(csr0 & ~(LE_C0_INEA|LE_C0_TDMD|LE_C0_STOP|LE_C0_STRT|LE_C0_INIT));
+        WRITERDP(lp, csr0 & ~(LE_C0_INEA|LE_C0_TDMD|LE_C0_STOP|LE_C0_STRT|LE_C0_INIT));
 
         if ((csr0 & LE_C0_ERR)) {
                 /* Clear the error condition */
-                WRITERDP(LE_C0_BABL|LE_C0_ERR|LE_C0_MISS|LE_C0_INEA);
+                WRITERDP(lp, LE_C0_BABL|LE_C0_ERR|LE_C0_MISS|LE_C0_INEA);
         }
 
         if (csr0 & LE_C0_RINT)
@@ -440,7 +479,7 @@
                 printk("%s: Bus master arbitration failure, status %4.4x.\n", 
                        dev->name, csr0);
                 /* Restart the chip. */
-                WRITERDP(LE_C0_STRT);
+                WRITERDP(lp, LE_C0_STRT);
         }
 
         if (lp->tx_full && netif_queue_stopped(dev) && (TX_BUFFS_AVAIL >= 0)) {
@@ -448,8 +487,8 @@
 		netif_wake_queue (dev);
         }
         
-        WRITERAP(LE_CSR0);
-        WRITERDP(LE_C0_BABL|LE_C0_CERR|LE_C0_MISS|LE_C0_MERR|LE_C0_IDON|LE_C0_INEA);
+        WRITERAP(lp, LE_CSR0);
+        WRITERDP(lp, LE_C0_BABL|LE_C0_CERR|LE_C0_MISS|LE_C0_MERR|LE_C0_IDON|LE_C0_INEA);
 
 	spin_unlock (&lp->devlock);
 	return IRQ_HANDLED;
@@ -459,7 +498,6 @@
 {
         struct lance_private *lp = netdev_priv(dev);
 	int res;
-        DECLARE_LL;
         
         /* Install the Interrupt handler. Or we could shunt this out to specific drivers? */
         if (request_irq(lp->irq, lance_interrupt, 0, lp->name, dev))
@@ -475,13 +513,12 @@
 int lance_close (struct net_device *dev)
 {
         struct lance_private *lp = netdev_priv(dev);
-        DECLARE_LL;
         
 	netif_stop_queue (dev);
 
         /* Stop the LANCE */
-        WRITERAP(LE_CSR0);
-        WRITERDP(LE_C0_STOP);
+        WRITERAP(lp, LE_CSR0);
+        WRITERDP(lp, LE_C0_STOP);
 
         free_irq(lp->irq, dev);
 
@@ -504,7 +541,6 @@
         int entry, skblen, len;
         static int outs;
 	unsigned long flags;
-        DECLARE_LL;
 
         if (!TX_BUFFS_AVAIL)
                 return -1;
@@ -540,7 +576,7 @@
 
         outs++;
         /* Kick the lance: transmit now */
-        WRITERDP(LE_C0_INEA | LE_C0_TDMD);
+        WRITERDP(lp, LE_C0_INEA | LE_C0_TDMD);
         dev->trans_start = jiffies;
         dev_kfree_skb (skb);
     
@@ -604,7 +640,6 @@
         struct lance_private *lp = netdev_priv(dev);
         volatile struct lance_init_block *ib = lp->init_block;
 	int stopped;
-        DECLARE_LL;
 
 	stopped = netif_queue_stopped(dev);
 	if (!stopped)
@@ -613,8 +648,8 @@
         while (lp->tx_old != lp->tx_new)
                 schedule();
 
-        WRITERAP(LE_CSR0);
-        WRITERDP(LE_C0_STOP);
+        WRITERAP(lp, LE_CSR0);
+        WRITERDP(lp, LE_C0_STOP);
         lance_init_ring (dev);
 
         if (dev->flags & IFF_PROMISC) {
@@ -630,4 +665,17 @@
 		netif_start_queue (dev);
 }
 
+#ifdef CONFIG_NET_POLL_CONTROLLER
+void lance_poll(struct net_device *dev)
+{
+	struct lance_private *lp = netdev_priv(dev);
+
+	spin_lock (&lp->devlock);
+	WRITERAP(lp, LE_CSR0);
+	WRITERDP(lp, LE_C0_STRT);
+	spin_unlock (&lp->devlock);
+	lance_interrupt(dev->irq, dev, NULL);
+}
+#endif
+
 MODULE_LICENSE("GPL");
diff -Naur linux-2.6.8.1/drivers/net/7990.h linux-2.6.8.1-m68k-20040817/drivers/net/7990.h
--- linux-2.6.8.1/drivers/net/7990.h	2004-08-14 20:54:50.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/drivers/net/7990.h	2004-07-16 06:07:30.000000000 +1000
@@ -14,11 +14,8 @@
 #define _7990_H
 
 /* The lance only has two register locations. We communicate mostly via memory. */
-struct lance_regs 
-{
-        unsigned short rdp;                       /* Register Data Port */
-        unsigned short rap;                       /* Register Address Port */
-};
+#define LANCE_RDP	0	/* Register Data Port */
+#define LANCE_RAP	2	/* Register Address Port */
 
 /* Transmit/receive ring definitions.
  * We allow the specific drivers to override these defaults if they want to.
@@ -104,7 +101,7 @@
 struct lance_private
 {
         char *name;
-        volatile struct lance_regs *ll;
+	unsigned long base;
         volatile struct lance_init_block *init_block; /* CPU address of RAM */
         volatile struct lance_init_block *lance_init_block; /* LANCE address of RAM */
         
@@ -252,5 +249,8 @@
 extern struct net_device_stats *lance_get_stats (struct net_device *dev);
 extern void lance_set_multicast (struct net_device *dev);
 extern void lance_tx_timeout(struct net_device *dev);
+#ifdef CONFIG_NET_POLL_CONTROLLER
+extern void lance_poll(struct net_device *dev);
+#endif
 
 #endif /* ndef _7990_H */
diff -Naur linux-2.6.8.1/drivers/net/Kconfig linux-2.6.8.1-m68k-20040817/drivers/net/Kconfig
--- linux-2.6.8.1/drivers/net/Kconfig	2004-08-14 20:56:00.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/drivers/net/Kconfig	2004-08-16 01:24:27.000000000 +1000
@@ -318,7 +318,7 @@
 
 config MAC89x0
 	tristate "Macintosh CS89x0 based ethernet cards"
-	depends on NETDEVICES && MAC && BROKEN
+	depends on NETDEVICES && MAC
 	---help---
 	  Support for CS89x0 chipset based Ethernet cards.  If you have a
 	  Nubus or LC-PDS network (Ethernet) card of this type, say Y and
@@ -391,7 +391,7 @@
 
 config ATARI_BIONET
 	tristate "BioNet-100 support"
-	depends on NETDEVICES && ATARI && ATARI_ACSI!=n && BROKEN
+	depends on NETDEVICES && ATARI && ATARI_ACSI && BROKEN
 	help
 	  Say Y to include support for BioData's BioNet-100 Ethernet adapter
 	  for the ACSI port. The driver works (has to work...) with a polled
@@ -399,7 +399,7 @@
 
 config ATARI_PAMSNET
 	tristate "PAMsNet support"
-	depends on NETDEVICES && ATARI && ATARI_ACSI!=n && BROKEN
+	depends on NETDEVICES && ATARI && ATARI_ACSI && BROKEN
 	help
 	  Say Y to include support for the PAMsNet Ethernet adapter for the
 	  ACSI port ("ACSI node"). The driver works (has to work...) with a
diff -Naur linux-2.6.8.1/drivers/net/hplance.c linux-2.6.8.1-m68k-20040817/drivers/net/hplance.c
--- linux-2.6.8.1/drivers/net/hplance.c	2004-08-14 20:55:32.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/drivers/net/hplance.c	2004-07-16 06:07:30.000000000 +1000
@@ -42,7 +42,6 @@
 struct hplance_private {
   struct lance_private lance;
   unsigned int scode;
-  void *base;
 };
 
 /* function prototypes... This is easy because all the grot is in the
@@ -91,15 +90,17 @@
         {
                 int scode = dio_find(DIO_ID_LAN);
                                 
-                if (!scode)
+                if (scode < 0)
                         break;
                 
 		dio_config_board(scode);
                 hplance_init(dev, scode);
 		if (!register_netdev(dev)) {
+#ifdef MODULE
 			struct hplance_private *lp = netdev_priv(dev);
 			lp->next_module = root_hplance_dev;
 			root_hplance_dev = lp;
+#endif
 			return dev;
 		}
 		cleanup_card(dev);
@@ -112,20 +113,24 @@
 static void __init hplance_init(struct net_device *dev, int scode)
 {
         const char *name = dio_scodetoname(scode);
-        void *va = dio_scodetoviraddr(scode);
+	unsigned long pa = dio_scodetophysaddr(scode);
+        unsigned long va = (pa + DIO_VIRADDRBASE);
         struct hplance_private *lp;
         int i;
         
-        printk("%s: %s; select code %d, addr", dev->name, name, scode);
+        printk(KERN_INFO "%s: %s; select code %d, addr", dev->name, name, scode);
 
         /* reset the board */
         out_8(va+DIO_IDOFF, 0xff);
         udelay(100);                              /* ariba! ariba! udelay! udelay! */
 
         /* Fill the dev fields */
-        dev->base_addr = (unsigned long)va;
+        dev->base_addr = va;
         dev->open = &hplance_open;
         dev->stop = &hplance_close;
+#ifdef CONFIG_NET_POLL_CONTROLLER
+        dev->poll_controller = lance_poll;
+#endif
         dev->hard_start_xmit = &lance_start_xmit;
         dev->get_stats = &lance_get_stats;
         dev->set_multicast_list = &lance_set_multicast;
@@ -143,7 +148,7 @@
         
         lp = netdev_priv(dev);
         lp->lance.name = (char*)name;                   /* discards const, shut up gcc */
-        lp->lance.ll = (struct lance_regs *)(va + HPLANCE_REGOFF);
+        lp->lance.base = va;
         lp->lance.init_block = (struct lance_init_block *)(va + HPLANCE_MEMOFF); /* CPU addr */
         lp->lance.lance_init_block = 0;                 /* LANCE addr of same RAM */
         lp->lance.busmaster_regval = LE_C3_BSWP;        /* we're bigendian */
@@ -156,7 +161,6 @@
         lp->lance.rx_ring_mod_mask = RX_RING_MOD_MASK;
         lp->lance.tx_ring_mod_mask = TX_RING_MOD_MASK;
         lp->scode = scode;
-	lp->base = va;
 	printk(", irq %d\n", lp->lance.irq);
 }
 
@@ -165,53 +169,49 @@
  */
 static void hplance_writerap(void *priv, unsigned short value)
 {
-	struct hplance_private *lp = (struct hplance_private *)priv;
-        struct hplance_reg *hpregs = (struct hplance_reg *)lp->base;
-        do {
-                lp->lance.ll->rap = value;
-        } while ((hpregs->status & LE_ACK) == 0);
+	struct lance_private *lp = (struct lance_private *)priv;
+	do {
+		out_be16(lp->base + HPLANCE_REGOFF + LANCE_RAP, value);
+	} while ((in_8(lp->base + HPLANCE_STATUS) & LE_ACK) == 0);
 }
 
 static void hplance_writerdp(void *priv, unsigned short value)
 {
-	struct hplance_private *lp = (struct hplance_private *)priv;
-        struct hplance_reg *hpregs = (struct hplance_reg *)lp->base;
-        do {
-                lp->lance.ll->rdp = value;
-        } while ((hpregs->status & LE_ACK) == 0);
+	struct lance_private *lp = (struct lance_private *)priv;
+	do {
+		out_be16(lp->base + HPLANCE_REGOFF + LANCE_RDP, value);
+	} while ((in_8(lp->base + HPLANCE_STATUS) & LE_ACK) == 0);
 }
 
 static unsigned short hplance_readrdp(void *priv)
 {
-        unsigned short val;
-	struct hplance_private *lp = (struct hplance_private *)priv;
-        struct hplance_reg *hpregs = (struct hplance_reg *)lp->base;
-        do {
-                val = lp->lance.ll->rdp;
-        } while ((hpregs->status & LE_ACK) == 0);
-        return val;
+	struct lance_private *lp = (struct lance_private *)priv;
+	__u16 value;
+	do {
+		value = in_be16(lp->base + HPLANCE_REGOFF + LANCE_RDP);
+	} while ((in_8(lp->base + HPLANCE_STATUS) & LE_ACK) == 0);
+	return value;
 }
 
 static int hplance_open(struct net_device *dev)
 {
         int status;
-        struct hplance_private *lp = netdev_priv(dev);
-        struct hplance_reg *hpregs = (struct hplance_reg *)lp->base;
+        struct lance_private *lp = netdev_priv(dev);
         
         status = lance_open(dev);                 /* call generic lance open code */
         if (status)
                 return status;
         /* enable interrupts at board level. */
-        out_8(&(hpregs->status), LE_IE);
+        out_8(lp->base + HPLANCE_STATUS, LE_IE);
 
         return 0;
 }
 
 static int hplance_close(struct net_device *dev)
 {
-        struct hplance_private *lp = netdev_priv(dev);
-        struct hplance_reg *hpregs = (struct hplance_reg *)lp->base;
-        out_8(&(hpregs->status), 8);              /* disable interrupts at boardlevel */
+        struct lance_private *lp = netdev_priv(dev);
+
+        out_8(lp->base + HPLANCE_STATUS, 0);	/* disable interrupts at boardlevel */
         lance_close(dev);
         return 0;
 }
diff -Naur linux-2.6.8.1/drivers/net/hplance.h linux-2.6.8.1-m68k-20040817/drivers/net/hplance.h
--- linux-2.6.8.1/drivers/net/hplance.h	2004-08-14 20:54:47.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/drivers/net/hplance.h	2004-07-12 01:30:02.000000000 +1000
@@ -4,15 +4,10 @@
  */
 
 /* Registers */
-struct hplance_reg
-{
-        u_char pad0;
-        volatile u_char id;                       /* DIO register: ID byte */
-        u_char pad1;
-        volatile u_char status;                   /* DIO register: interrupt enable */
-};
+#define HPLANCE_ID		0x01		/* DIO register: ID byte */
+#define HPLANCE_STATUS		0x03		/* DIO register: interrupt enable/status */
 
-/* Control and status bits for the hplance->status register */
+/* Control and status bits for the status register */
 #define LE_IE 0x80                                /* interrupt enable */
 #define LE_IR 0x40                                /* interrupt requested */
 #define LE_LOCK 0x08                              /* lock status register */
@@ -25,7 +20,7 @@
 /* These are the offsets for the DIO regs (hplance_reg), lance_ioreg,
  * memory and NVRAM:
  */
-#define HPLANCE_IDOFF 0                           /* board baseaddr, struct hplance_reg */
-#define HPLANCE_REGOFF 0x4000                     /* struct lance_regs */
+#define HPLANCE_IDOFF 0                           /* board baseaddr */
+#define HPLANCE_REGOFF 0x4000                     /* lance registers */
 #define HPLANCE_MEMOFF 0x8000                     /* struct lance_init_block */
 #define HPLANCE_NVRAMOFF 0xC008                   /* etheraddress as one *nibble* per byte */
diff -Naur linux-2.6.8.1/drivers/net/mac89x0.c linux-2.6.8.1-m68k-20040817/drivers/net/mac89x0.c
--- linux-2.6.8.1/drivers/net/mac89x0.c	2004-08-14 20:55:32.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/drivers/net/mac89x0.c	2004-04-04 21:02:09.000000000 +1000
@@ -127,7 +127,7 @@
 extern void reset_chip(struct net_device *dev);
 #endif
 static int net_open(struct net_device *dev);
-static int	net_send_packet(struct sk_buff *skb, struct net_device *dev);
+static int net_send_packet(struct sk_buff *skb, struct net_device *dev);
 static irqreturn_t net_interrupt(int irq, void *dev_id, struct pt_regs *regs);
 static void set_multicast_list(struct net_device *dev);
 static void net_rx(struct net_device *dev);
@@ -374,56 +374,37 @@
 static int
 net_send_packet(struct sk_buff *skb, struct net_device *dev)
 {
-	if (dev->tbusy) {
-		/* If we get here, some higher level has decided we are broken.
-		   There should really be a "kick me" function call instead. */
-		int tickssofar = jiffies - dev->trans_start;
-		if (tickssofar < 5)
-			return 1;
-		if (net_debug > 0) printk("%s: transmit timed out, %s?\n", dev->name,
-			   tx_done(dev) ? "IRQ conflict" : "network cable problem");
-		/* Try to restart the adaptor. */
-		dev->tbusy=0;
-		dev->trans_start = jiffies;
-	}
-
-	/* Block a timer-based transmit from overlapping.  This could better be
-	   done with atomic_swap(1, dev->tbusy), but set_bit() works as well. */
-	if (test_and_set_bit(0, (void*)&dev->tbusy) != 0)
-		printk("%s: Transmitter access conflict.\n", dev->name);
-	else {
-		struct net_local *lp = netdev_priv(dev);
-		unsigned long flags;
-
-		if (net_debug > 3)
-			printk("%s: sent %d byte packet of type %x\n",
-			       dev->name, skb->len,
-			       (skb->data[ETH_ALEN+ETH_ALEN] << 8)
-			       | skb->data[ETH_ALEN+ETH_ALEN+1]);
-
-		/* keep the upload from being interrupted, since we
-                   ask the chip to start transmitting before the
-                   whole packet has been completely uploaded. */
-		local_irq_save(flags);
-
-		/* initiate a transmit sequence */
-		writereg(dev, PP_TxCMD, lp->send_cmd);
-		writereg(dev, PP_TxLength, skb->len);
-
-		/* Test to see if the chip has allocated memory for the packet */
-		if ((readreg(dev, PP_BusST) & READY_FOR_TX_NOW) == 0) {
-			/* Gasp!  It hasn't.  But that shouldn't happen since
-			   we're waiting for TxOk, so return 1 and requeue this packet. */
-			local_irq_restore(flags);
-			return 1;
-		}
+	struct net_local *lp = netdev_priv(dev);
+	unsigned long flags;
 
-		/* Write the contents of the packet */
-		memcpy_toio(dev->mem_start + PP_TxFrame, skb->data, skb->len+1);
+	if (net_debug > 3)
+		printk("%s: sent %d byte packet of type %x\n",
+		       dev->name, skb->len,
+		       (skb->data[ETH_ALEN+ETH_ALEN] << 8)
+		       | skb->data[ETH_ALEN+ETH_ALEN+1]);
+
+	/* keep the upload from being interrupted, since we
+	   ask the chip to start transmitting before the
+	   whole packet has been completely uploaded. */
+	local_irq_save(flags);
 
+	/* initiate a transmit sequence */
+	writereg(dev, PP_TxCMD, lp->send_cmd);
+	writereg(dev, PP_TxLength, skb->len);
+
+	/* Test to see if the chip has allocated memory for the packet */
+	if ((readreg(dev, PP_BusST) & READY_FOR_TX_NOW) == 0) {
+		/* Gasp!  It hasn't.  But that shouldn't happen since
+		   we're waiting for TxOk, so return 1 and requeue this packet. */
 		local_irq_restore(flags);
-		dev->trans_start = jiffies;
+		return 1;
 	}
+
+	/* Write the contents of the packet */
+	memcpy((void *)(dev->mem_start + PP_TxFrame), skb->data, skb->len+1);
+
+	local_irq_restore(flags);
+	dev->trans_start = jiffies;
 	dev_kfree_skb (skb);
 
 	return 0;
@@ -441,9 +422,6 @@
 		printk ("net_interrupt(): irq %d for unknown device.\n", irq);
 		return IRQ_NONE;
 	}
-	if (dev->interrupt)
-		printk("%s: Re-entering the interrupt handler.\n", dev->name);
-	dev->interrupt = 1;
 
 	ioaddr = dev->base_addr;
 	lp = netdev_priv(dev);
@@ -464,8 +442,7 @@
 			break;
 		case ISQ_TRANSMITTER_EVENT:
 			lp->stats.tx_packets++;
-			dev->tbusy = 0;
-			mark_bh(NET_BH);	/* Inform upper layers. */
+			netif_wake_queue(dev);
 			if ((status & TX_OK) == 0) lp->stats.tx_errors++;
 			if (status & TX_LOST_CRS) lp->stats.tx_carrier_errors++;
 			if (status & TX_SQE_ERROR) lp->stats.tx_heartbeat_errors++;
@@ -479,8 +456,7 @@
                                    That shouldn't happen since we only ever
                                    load one packet.  Shrug.  Do the right
                                    thing anyway. */
-				dev->tbusy = 0;
-				mark_bh(NET_BH);	/* Inform upper layers. */
+				netif_wake_queue(dev);
 			}
 			if (status & TX_UNDERRUN) {
 				if (net_debug > 0) printk("%s: transmit underrun\n", dev->name);
@@ -497,7 +473,6 @@
 			break;
 		}
 	}
-	dev->interrupt = 0;
 	return IRQ_HANDLED;
 }
 
@@ -532,7 +507,7 @@
 	skb_put(skb, length);
 	skb->dev = dev;
 
-	memcpy_fromio(skb->data, dev->mem_start + PP_RxFrame, length);
+	memcpy(skb->data, (void *)(dev->mem_start + PP_RxFrame), length);
 
 	if (net_debug > 3)printk("%s: received %d byte packet of type %x\n",
                                  dev->name, length,
@@ -611,8 +586,6 @@
 static int set_mac_address(struct net_device *dev, void *addr)
 {
 	int i;
-	if (dev->start)
-		return -EBUSY;
 	printk("%s: Setting MAC address to ", dev->name);
 	for (i = 0; i < 6; i++)
 		printk(" %2.2x", dev->dev_addr[i] = ((unsigned char *)addr)[i]);
diff -Naur linux-2.6.8.1/drivers/net/mvme147.c linux-2.6.8.1-m68k-20040817/drivers/net/mvme147.c
--- linux-2.6.8.1/drivers/net/mvme147.c	2004-08-14 20:55:10.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/drivers/net/mvme147.c	2004-07-12 01:30:02.000000000 +1000
@@ -18,7 +18,6 @@
 /* Used for the temporal inet entries and routing */
 #include <linux/socket.h>
 #include <linux/route.h>
-#include <linux/dio.h>
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
 #include <linux/skbuff.h>
@@ -40,7 +39,6 @@
 /* Our private data structure */
 struct m147lance_private {
 	struct lance_private lance;
-	void *base;
 	unsigned long ram;
 };
 
@@ -51,9 +49,9 @@
  */
 static int m147lance_open(struct net_device *dev);
 static int m147lance_close(struct net_device *dev);
-static void m147lance_writerap(struct m147lance_private *lp, unsigned short value);
-static void m147lance_writerdp(struct m147lance_private *lp, unsigned short value);
-static unsigned short m147lance_readrdp(struct m147lance_private *lp);
+static void m147lance_writerap(struct lance_private *lp, unsigned short value);
+static void m147lance_writerdp(struct lance_private *lp, unsigned short value);
+static unsigned short m147lance_readrdp(struct lance_private *lp);
 
 typedef void (*writerap_t)(void *, unsigned short);
 typedef void (*writerdp_t)(void *, unsigned short);
@@ -122,7 +120,7 @@
 	}
 
 	lp->lance.name = (char*)name;                   /* discards const, shut up gcc */
-	lp->lance.ll = (struct lance_regs *)(dev->base_addr);
+	lp->lance.base = dev->base_addr;
 	lp->lance.init_block = (struct lance_init_block *)(lp->ram); /* CPU addr */
 	lp->lance.lance_init_block = (struct lance_init_block *)(lp->ram);                 /* LANCE addr of same RAM */
 	lp->lance.busmaster_regval = LE_C3_BSWP;        /* we're bigendian */
@@ -145,19 +143,19 @@
 	return dev;
 }
 
-static void m147lance_writerap(struct m147lance_private *lp, unsigned short value)
+static void m147lance_writerap(struct lance_private *lp, unsigned short value)
 {
-	lp->lance.ll->rap = value;
+	out_be16(lp->base + LANCE_RAP, value);
 }
 
-static void m147lance_writerdp(struct m147lance_private *lp, unsigned short value)
+static void m147lance_writerdp(struct lance_private *lp, unsigned short value)
 {
-	lp->lance.ll->rdp = value;
+	out_be16(lp->base + LANCE_RDP, value);
 }
 
-static unsigned short m147lance_readrdp(struct m147lance_private *lp)
+static unsigned short m147lance_readrdp(struct lance_private *lp)
 {
-	return lp->lance.ll->rdp;
+	return in_be16(lp->base + LANCE_RDP);
 }
 
 static int m147lance_open(struct net_device *dev)
diff -Naur linux-2.6.8.1/drivers/scsi/NCR5380.c linux-2.6.8.1-m68k-20040817/drivers/scsi/NCR5380.c
--- linux-2.6.8.1/drivers/scsi/NCR5380.c	2004-08-14 20:54:52.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/drivers/scsi/NCR5380.c	2004-08-16 01:24:28.000000000 +1000
@@ -390,6 +390,7 @@
 	return -ETIMEDOUT;
 }
 
+#ifdef NDEBUG
 static struct {
 	unsigned char value;
 	const char *name;
@@ -403,7 +404,6 @@
 	{PHASE_UNKNOWN, "UNKNOWN"}
 };
 
-#ifdef NDEBUG
 static struct {
 	unsigned char mask;
 	const char *name;
diff -Naur linux-2.6.8.1/drivers/serial/8250_hp300.c linux-2.6.8.1-m68k-20040817/drivers/serial/8250_hp300.c
--- linux-2.6.8.1/drivers/serial/8250_hp300.c	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/drivers/serial/8250_hp300.c	2004-08-16 18:42:53.000000000 +1000
@@ -0,0 +1,330 @@
+/*
+ * Driver for the 98626/98644/internal serial interface on hp300/hp400
+ * (based on the National Semiconductor INS8250/NS16550AF/WD16C552 UARTs)
+ *
+ * Ported from 2.2 and modified to use the normal 8250 driver
+ * by Kars de Jong <jongk@linux-m68k.org>, May 2004.
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/tty.h>
+#include <linux/serial.h>
+#include <linux/serialP.h>
+#include <linux/serial_core.h>
+#include <linux/delay.h>
+#include <linux/dio.h>
+#include <linux/console.h>
+#include <asm/io.h>
+
+#if !defined(CONFIG_HPDCA) && !defined(CONFIG_HPAPCI)
+#warning CONFIG_8250 defined but neither CONFIG_HPDCA nor CONFIG_HPAPCI defined, are you sure?
+#endif
+
+struct hp300_port
+{
+	struct hp300_port *next;	/* next port */
+	unsigned long dio_base;		/* start of DIO registers */
+	int scode;                      /* select code of this board */
+	int line;			/* line (tty) number */
+};
+
+extern int hp300_uart_scode;
+
+static struct hp300_port *hp300_ports;
+
+/* Offset to UART registers from base of DCA */
+#define UART_OFFSET	17
+
+#define DCA_ID		0x01	/* ID (read), reset (write) */
+#define DCA_IC		0x03	/* Interrupt control        */
+
+/* Interrupt control */
+#define DCA_IC_IE	0x80	/* Master interrupt enable  */
+
+#define HPDCA_BAUD_BASE 153600
+
+/* Base address of the Frodo part */
+#define FRODO_BASE	(0x41c000)
+
+/*
+ * Where we find the 8250-like APCI ports, and how far apart they are.
+ */
+#define FRODO_APCIBASE		0x0
+#define FRODO_APCISPACE		0x20
+#define FRODO_APCI_OFFSET(x)	(FRODO_APCIBASE + ((x) * FRODO_APCISPACE))
+
+#define HPAPCI_BAUD_BASE 500400
+
+#ifdef CONFIG_SERIAL_8250_CONSOLE
+/*
+ * Parse the bootinfo to find descriptions for headless console and 
+ * debug serial ports and register them with the 8250 driver.
+ * This function should be called before serial_console_init() is called
+ * to make sure the serial console will be available for use. IA-64 kernel
+ * calls this function from setup_arch() after the EFI and ACPI tables have
+ * been parsed.
+ */
+int __init hp300_setup_serial_console(void)
+{
+	int scode;
+	struct uart_port port;
+
+	memset(&port, 0, sizeof(port));
+
+	if (hp300_uart_scode < 0 || hp300_uart_scode > 256)
+		return 0;
+
+	scode = hp300_uart_scode;
+
+	/* Memory mapped I/O */
+	port.iotype = UPIO_MEM;
+	port.flags = UPF_SKIP_TEST | UPF_SHARE_IRQ | UPF_BOOT_AUTOCONF;
+	port.type = PORT_UNKNOWN;
+
+	/* Check for APCI console */
+	if (scode == 256)
+	{
+#ifdef CONFIG_HPAPCI
+		printk(KERN_INFO "Serial console is HP APCI 1\n");
+
+		port.uartclk = HPAPCI_BAUD_BASE * 16;
+		port.mapbase = (FRODO_BASE + FRODO_APCI_OFFSET(1));
+		port.membase = (char *)(port.mapbase + DIO_VIRADDRBASE);
+		port.regshift = 2;
+		add_preferred_console("ttyS", port.line, "9600n8");
+#else
+		printk(KERN_WARNING "Serial console is APCI but support is disabled (CONFIG_HPAPCI)!\n");
+		return 0;
+#endif
+	}
+	else
+	{
+#ifdef CONFIG_HPDCA
+		unsigned long pa = dio_scodetophysaddr(scode);
+		if (!pa) {
+			return 0;
+		}
+
+		printk(KERN_INFO "Serial console is HP DCA at select code %d\n", scode);
+
+		port.uartclk = HPDCA_BAUD_BASE * 16;
+		port.mapbase = (pa + UART_OFFSET);
+		port.membase = (char *)(port.mapbase + DIO_VIRADDRBASE);
+		port.regshift = 1;
+		port.irq = DIO_IPL(pa + DIO_VIRADDRBASE);
+
+		/* Enable board-interrupts */
+		out_8(pa + DIO_VIRADDRBASE + DCA_IC, DCA_IC_IE);
+
+		if (DIO_ID(pa + DIO_VIRADDRBASE) & 0x80) {
+			add_preferred_console("ttyS", port.line, "9600n8");
+		}
+#else
+		printk(KERN_WARNING "Serial console is DCA but support is disabled (CONFIG_HPDCA)!\n");
+		return 0;
+#endif
+	}
+
+	if (early_serial_setup(&port) < 0) {
+		printk(KERN_WARNING "hp300_setup_serial_console(): early_serial_setup() failed.\n");
+	}
+
+	return 0;
+}
+#endif /* CONFIG_SERIAL_8250_CONSOLE */
+
+static int __init hp300_8250_init(void)
+{
+	static int called = 0;
+#ifdef CONFIG_HPDCA
+	int scode;
+#endif
+	int line, num_ports;
+	unsigned long base;
+	struct serial_struct serial_req;
+	struct hp300_port *port;
+
+	if (called)
+		return -ENODEV;
+	called = 1;
+	num_ports = 0;
+
+	if (!MACH_IS_HP300) {
+		return -ENODEV;
+	}
+
+#ifdef CONFIG_HPDCA
+	while (1) {
+                /* We detect boards by looking for DIO boards which match a
+                 * given subset of IDs. dio_find() returns the board's scancode.
+                 * The scancode to physaddr mapping is a property of the hardware,
+                 * as is the scancode to IPL (interrupt priority) mapping.
+                 */
+                scode = dio_find(DIO_ID_DCA0);
+                if (scode < 0)
+			scode = dio_find(DIO_ID_DCA0REM);
+                if (scode < 0)
+			scode = dio_find(DIO_ID_DCA1);
+                if (scode < 0)
+			scode = dio_find(DIO_ID_DCA1REM);
+                if (scode < 0)
+			break;		/* no, none at all */
+
+#ifdef CONFIG_SERIAL_8250_CONSOLE
+		if (hp300_uart_scode == scode) {
+			/* Already got it */
+			dio_config_board(scode);
+			continue;
+		}
+#endif
+
+		/* Create new serial device */
+		port = kmalloc(sizeof(struct hp300_port), GFP_KERNEL);
+		if (!port)
+			return -ENOMEM;
+
+		memset(&serial_req, 0, sizeof(struct serial_struct));
+		
+		base = dio_scodetophysaddr(scode);
+
+                /* If we want to tell the DIO code that this board is configured,
+                 * we should do that here.
+                 */
+                dio_config_board(scode);
+
+		/* Memory mapped I/O */
+		serial_req.io_type = SERIAL_IO_MEM;
+		serial_req.flags = UPF_SKIP_TEST | UPF_SHARE_IRQ | UPF_BOOT_AUTOCONF;
+		serial_req.irq = dio_scodetoipl(scode);
+		serial_req.baud_base = HPDCA_BAUD_BASE;
+		serial_req.iomap_base = (base + UART_OFFSET);
+		serial_req.iomem_base = (char *)(serial_req.iomap_base + DIO_VIRADDRBASE);
+		serial_req.iomem_reg_shift = 1;
+
+#ifdef CONFIG_SERIAL_8250_CONSOLE
+		if (hp300_uart_scode != scode) {
+#endif
+                /* Reset the DCA */
+                out_8(base + DIO_VIRADDRBASE + DCA_ID, 0xff);
+                udelay(100);
+#ifdef CONFIG_SERIAL_8250_CONSOLE
+		}
+#endif
+
+		line = register_serial(&serial_req);
+
+		if (line < 0) {
+			printk(KERN_NOTICE "8250_hp300: register_serial() DCA scode %d"
+			       " irq %d failed\n", scode, serial_req.irq);
+			kfree(port);
+			continue;
+		}
+
+		/* Enable board-interrupts */
+		out_8(base + DIO_VIRADDRBASE + DCA_IC, DCA_IC_IE);
+
+		port->dio_base = base + DIO_VIRADDRBASE;
+		port->scode = scode;
+		port->line = line;
+		port->next = hp300_ports;
+		hp300_ports = port;
+
+		num_ports++;
+        }
+#endif
+
+#ifdef CONFIG_HPAPCI
+	if (hp300_model >= HP_400)
+	{
+		int i;
+
+		/* These models have the Frodo chip.
+		 * Port 0 is reserved for the Apollo Domain keyboard.
+		 * Port 1 is either the console or the DCA.
+		 */
+		for (i = 1; i < 4; i++) {
+			/* Port 1 is the console on a 425e, on other machines it's mapped to
+			 * DCA.
+			 */
+#ifdef CONFIG_SERIAL_8250_CONSOLE
+			if (i == 1) {
+				continue;
+			}
+#endif
+
+			/* Create new serial device */
+			port = kmalloc(sizeof(struct hp300_port), GFP_KERNEL);
+			if (!port)
+				return -ENOMEM;
+
+			memset(&serial_req, 0, sizeof(struct serial_struct));
+
+			base = (FRODO_BASE + FRODO_APCI_OFFSET(i));
+
+			/* Memory mapped I/O */
+			serial_req.io_type = SERIAL_IO_MEM;
+			serial_req.flags = UPF_SKIP_TEST | UPF_SHARE_IRQ | UPF_BOOT_AUTOCONF;
+			/* XXX - no interrupt support yet */
+			serial_req.irq = 0;
+			serial_req.baud_base = HPAPCI_BAUD_BASE;
+			serial_req.iomap_base = base;
+			serial_req.iomem_base = (char *)(serial_req.iomap_base + DIO_VIRADDRBASE);
+			serial_req.iomem_reg_shift = 2;
+
+			line = register_serial(&serial_req);
+
+			if (line < 0) {
+				printk(KERN_NOTICE "8250_hp300: register_serial() APCI %d"
+				       " irq %d failed\n", i, serial_req.irq);
+				kfree(port);
+				continue;
+			}
+
+			port->dio_base = 0;
+			port->line = line;
+			port->next = hp300_ports;
+			hp300_ports = port;
+
+			num_ports++;
+		}
+	}
+#endif
+
+	/* Any boards found? */
+	if (!num_ports)
+		return -ENODEV;
+
+	return 0;
+}
+
+static void __exit hp300_8250_exit(void)
+{
+	struct hp300_port *port, *to_free;
+
+	for (port = hp300_ports; port; ) {
+		unregister_serial(port->line);
+
+#ifdef CONFIG_HPDCA
+		if (port->dio_base) {
+			/* Disable board-interrupts */
+			out_8(port->dio_base + DCA_IC, 0);
+
+			dio_unconfig_board(port->scode);
+		}
+#endif
+
+		to_free = port;
+		port = port->next;
+		kfree(to_free);
+	}
+
+	hp300_ports = NULL;
+}
+
+module_init(hp300_8250_init);
+module_exit(hp300_8250_exit);
+MODULE_DESCRIPTION("HP DCA/APCI serial driver");
+MODULE_AUTHOR("Kars de Jong <jongk@linux-m68k.org>");
+MODULE_LICENSE("GPL");
diff -Naur linux-2.6.8.1/drivers/serial/Makefile linux-2.6.8.1-m68k-20040817/drivers/serial/Makefile
--- linux-2.6.8.1/drivers/serial/Makefile	2004-08-14 20:55:32.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/drivers/serial/Makefile	2004-08-16 01:24:29.000000000 +1000
@@ -9,6 +9,7 @@
 serial-8250-$(CONFIG_GSC) += 8250_gsc.o
 serial-8250-$(CONFIG_PCI) += 8250_pci.o
 serial-8250-$(CONFIG_PNP) += 8250_pnp.o
+serial-8250-$(CONFIG_HP300) += 8250_hp300.o
 
 obj-$(CONFIG_SERIAL_CORE) += serial_core.o
 obj-$(CONFIG_SERIAL_21285) += 21285.o
diff -Naur linux-2.6.8.1/drivers/video/fbmem.c linux-2.6.8.1-m68k-20040817/drivers/video/fbmem.c
--- linux-2.6.8.1/drivers/video/fbmem.c	2004-08-14 20:54:46.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/drivers/video/fbmem.c	2004-08-16 01:24:30.000000000 +1000
@@ -1572,9 +1572,9 @@
 						fb_drivers[i].init;
 					fb_drivers[i].init = NULL;
 				}
-				if (fb_drivers[i].setup)
-					fb_drivers[i].setup(options+j+1);
 			}
+			if (fb_drivers[i].setup)
+				fb_drivers[i].setup(options+j+1);
 			return 0;
 		}
 	}
diff -Naur linux-2.6.8.1/drivers/video/hpfb.c linux-2.6.8.1-m68k-20040817/drivers/video/hpfb.c
--- linux-2.6.8.1/drivers/video/hpfb.c	2004-08-14 20:55:33.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/drivers/video/hpfb.c	2004-07-16 06:07:31.000000000 +1000
@@ -1,6 +1,8 @@
 /*
  *	HP300 Topcat framebuffer support (derived from macfb of all things)
  *	Phil Blundell <philb@gnu.org> 1998
+ *	DIO-II, colour map and Catseye support by
+ *	Kars de Jong <jongk@linux-m68k.org>, May 2004.
  */
 
 #include <linux/module.h>
@@ -15,19 +17,36 @@
 #include <linux/init.h>
 #include <linux/fb.h>
 #include <linux/dio.h>
+
 #include <asm/io.h>
-#include <asm/blinken.h>
-#include <asm/hwtest.h>
+#include <asm/uaccess.h>
 
-static struct fb_info fb_info;
+static struct fb_info fb_info = {
+	.fix = {
+		.id		= "HP300 ",
+		.type		= FB_TYPE_PACKED_PIXELS,
+		.visual		= FB_VISUAL_PSEUDOCOLOR,
+		.accel		= FB_ACCEL_NONE,
+	}
+};
 
-unsigned long fb_regs;
-unsigned char fb_bitmask;
+static unsigned long fb_regs;
+static unsigned char fb_bitmask;
 
+#define TC_NBLANK	0x4080
 #define TC_WEN		0x4088
 #define TC_REN		0x408c
 #define TC_FBEN		0x4090
-#define TC_NBLANK	0x4080
+#define TC_PRR		0x40ea
+
+/* These defines match the X window system */
+#define RR_CLEAR	0x0
+#define RR_COPY		0x3
+#define RR_NOOP		0x5
+#define RR_XOR		0x6
+#define RR_INVERT	0xa
+#define RR_COPYINVERTED 0xc
+#define RR_SET		0xf
 
 /* blitter regs */
 #define BUSY		0x4044
@@ -40,126 +59,255 @@
 #define WWIDTH		0x4102
 #define WMOVE		0x409c
 
-static struct fb_fix_screeninfo hpfb_fix __initdata = {
-	.id		= "HP300 Topcat",
-	.smem_len	= 1024*768,
-	.type		= FB_TYPE_PACKED_PIXELS,
-	.visual		= FB_VISUAL_PSEUDOCOLOR,
-	.line_length	= 1024,
-	.accel		= FB_ACCEL_NONE,
-};
-
 static struct fb_var_screeninfo hpfb_defined = {
-	.xres		= 1024,
-	.yres		= 768,
-	.xres_virtual	= 1024,
-	.yres_virtual	= 786,
-	.bits_per_pixel	= 1,
-	.red		= {0,2,0},	/* R */
-	.green		= {0,2,0},	/* G */
-	.blue		= {0,2,0},	/* B */
+	.red		= {
+		.length = 8,
+	},
+	.green		= {
+		.length = 8,
+	},
+	.blue		= {
+		.length = 8,
+	},
 	.activate	= FB_ACTIVATE_NOW,
-	.height		= 274,
-	.width		= 195,	/* 14" monitor */
-	.accel_flags	= FB_ACCEL_NONE,
+	.height		= -1,
+	.width		= -1,
 	.vmode		= FB_VMODE_NONINTERLACED,
 };
 
-/*
- * Set the palette.  This may not work on all boards but only experimentation 
- * will tell.
- * XXX Doesn't work at all.
- */
 static int hpfb_setcolreg(unsigned regno, unsigned red, unsigned green,
-                           unsigned blue, unsigned transp,
-                           struct fb_info *info)
+			  unsigned blue, unsigned transp,
+			  struct fb_info *info)
 {
+	/* use MSBs */
+	unsigned char _red  =red>>8;
+	unsigned char _green=green>>8;
+	unsigned char _blue =blue>>8;
+	unsigned char _regno=regno;
+
+	/*
+	 *  Set a single color register. The values supplied are
+	 *  already rounded down to the hardware's capabilities
+	 *  (according to the entries in the `var' structure). Return
+	 *  != 0 for invalid regno.
+	 */
+
+	if (regno >= info->cmap.len)
+		return 1;
+	
 	while (in_be16(fb_regs + 0x6002) & 0x4) udelay(1);
-	out_be16(fb_regs + 0x60f0, 0);
-	out_be16(fb_regs + 0x60b8, regno);
-	out_be16(fb_regs + 0x60b2, red);
-	out_be16(fb_regs + 0x60b4, green);
-	out_be16(fb_regs + 0x60b6, blue);
+
+	out_be16(fb_regs + 0x60ba, 0xff);
+
+	out_be16(fb_regs + 0x60b2, _red);
+	out_be16(fb_regs + 0x60b4, _green);
+	out_be16(fb_regs + 0x60b6, _blue);
+	out_be16(fb_regs + 0x60b8, ~_regno);
 	out_be16(fb_regs + 0x60f0, 0xff);
+
 	udelay(100);
-	out_be16(fb_regs + 0x60ba, 0xffff);
+
+	while (in_be16(fb_regs + 0x6002) & 0x4) udelay(1);
+	out_be16(fb_regs + 0x60b2, 0);
+	out_be16(fb_regs + 0x60b4, 0);
+	out_be16(fb_regs + 0x60b6, 0);
+	out_be16(fb_regs + 0x60b8, 0);
+
+	return 0;
+}
+
+/* 0 unblank, 1 blank, 2 no vsync, 3 no hsync, 4 off */
+
+static int hpfb_blank(int blank, struct fb_info *info)
+{
+	out_8(fb_regs + TC_NBLANK, (blank ? 0x00 : fb_bitmask));
+
 	return 0;
 }
 
-void hpfb_copyarea(struct fb_info *info, const struct fb_copyarea *area) 
+static void topcat_blit(int x0, int y0, int x1, int y1, int w, int h, int rr)
 {
-	while (in_8(fb_regs + BUSY) & fb_bitmask);
-	out_8(fb_regs + WMRR, 0x3);
-	out_be16(fb_regs + SOURCE_X, area->sx);
-	out_be16(fb_regs + SOURCE_Y, area->sy);
-	out_be16(fb_regs + DEST_X, area->dx);
-	out_be16(fb_regs + DEST_Y, area->dy);
-	out_be16(fb_regs + WHEIGHT, area->height);
-	out_be16(fb_regs + WWIDTH, area->width);
+	if (rr >= 0)
+	{
+		while (in_8(fb_regs + BUSY) & fb_bitmask)
+			;
+	}
+	out_8(fb_regs + TC_FBEN, fb_bitmask);
+	if (rr >= 0)
+	{
+		out_8(fb_regs + TC_WEN, fb_bitmask);
+		out_8(fb_regs + WMRR, rr);
+	}
+	out_be16(fb_regs + SOURCE_X, x0);
+	out_be16(fb_regs + SOURCE_Y, y0);
+	out_be16(fb_regs + DEST_X, x1);
+	out_be16(fb_regs + DEST_Y, y1);
+	out_be16(fb_regs + WWIDTH, w);
+	out_be16(fb_regs + WHEIGHT, h);
 	out_8(fb_regs + WMOVE, fb_bitmask);
 }
 
+static void hpfb_copyarea(struct fb_info *info, const struct fb_copyarea *area) 
+{
+	topcat_blit(area->sx, area->sy, area->dx, area->dy, area->width, area->height, RR_COPY);
+}
+
+static void hpfb_fillrect(struct fb_info *p, const struct fb_fillrect *region)
+{
+	u8 clr;
+
+	clr = region->color & 0xff;
+
+	while (in_8(fb_regs + BUSY) & fb_bitmask)
+		;
+
+	/* Foreground */
+	out_8(fb_regs + TC_WEN, fb_bitmask & clr);
+	out_8(fb_regs + WMRR, (region->rop == ROP_COPY ? RR_SET : RR_INVERT));
+
+	/* Background */
+	out_8(fb_regs + TC_WEN, fb_bitmask & ~clr);
+	out_8(fb_regs + WMRR, (region->rop == ROP_COPY ? RR_CLEAR : RR_NOOP));
+
+	topcat_blit(region->dx, region->dy, region->dx, region->dy, region->width, region->height, -1);
+}
+
+static int hpfb_sync(struct fb_info *info)
+{
+	/*
+	 * Since we also access the framebuffer directly, we have to wait
+	 * until the block mover is finished
+	 */
+	while (in_8(fb_regs + BUSY) & fb_bitmask)
+		;
+
+	out_8(fb_regs + TC_WEN, fb_bitmask);
+	out_8(fb_regs + TC_PRR, RR_COPY);
+	out_8(fb_regs + TC_FBEN, fb_bitmask);
+
+	return 0;
+}
+
 static struct fb_ops hpfb_ops = {
 	.owner		= THIS_MODULE,
 	.fb_setcolreg	= hpfb_setcolreg,
-	.fb_fillrect	= cfb_fillrect,
+	.fb_blank	= hpfb_blank,
+	.fb_fillrect	= hpfb_fillrect,
 	.fb_copyarea	= hpfb_copyarea,
 	.fb_imageblit	= cfb_imageblit,
 	.fb_cursor	= soft_cursor,
+	.fb_sync	= hpfb_sync,
 };
 
-#define TOPCAT_FBOMSB	0x5d
-#define TOPCAT_FBOLSB	0x5f
+/* Common to all HP framebuffers */
+#define HPFB_FBWMSB	0x05	/* Frame buffer width 		*/
+#define HPFB_FBWLSB	0x07
+#define HPFB_FBHMSB	0x09	/* Frame buffer height		*/
+#define HPFB_FBHLSB	0x0b
+#define HPFB_DWMSB	0x0d	/* Display width		*/
+#define HPFB_DWLSB	0x0f
+#define HPFB_DHMSB	0x11	/* Display height		*/
+#define HPFB_DHLSB	0x13
+#define HPFB_NUMPLANES	0x5b	/* Number of colour planes	*/
+#define HPFB_FBOMSB	0x5d	/* Frame buffer offset		*/
+#define HPFB_FBOLSB	0x5f
 
-int __init hpfb_init_one(unsigned long base)
+static int __init hpfb_init_one(unsigned long phys_base, unsigned long virt_base)
 {
-	unsigned long fboff;
+	unsigned long fboff, fb_width, fb_height, fb_start;
+
+	fb_regs = virt_base;
+	fboff = (in_8(fb_regs + HPFB_FBOMSB) << 8) | in_8(fb_regs + HPFB_FBOLSB);
+
+	fb_info.fix.smem_start = (in_8(fb_regs + fboff) << 16);
+
+	if (phys_base >= DIOII_BASE)
+	{
+		fb_info.fix.smem_start += phys_base;
+	}
 
-	fboff = (in_8(base + TOPCAT_FBOMSB) << 8) | in_8(base + TOPCAT_FBOLSB);
+	if (DIO_SECID(fb_regs) != DIO_ID2_TOPCAT)
+	{
+		/* This is the magic incantation the HP X server uses to make Catseye boards work. */
+		while (in_be16(fb_regs+0x4800) & 1)
+			;
+		out_be16(fb_regs+0x4800, 0);	/* Catseye status */
+		out_be16(fb_regs+0x4510, 0);	/* VB */
+		out_be16(fb_regs+0x4512, 0);	/* TCNTRL */
+		out_be16(fb_regs+0x4514, 0);	/* ACNTRL */
+		out_be16(fb_regs+0x4516, 0);	/* PNCNTRL */
+		out_be16(fb_regs+0x4206, 0x90);	/* RUG Command/Status */
+		out_be16(fb_regs+0x60a2, 0);	/* Overlay Mask */
+		out_be16(fb_regs+0x60bc, 0);	/* Ram Select */
+	}
+
+	/*
+	 *	Fill in the available video resolution
+	 */
+	fb_width = (in_8(fb_regs + HPFB_FBWMSB) << 8) | in_8(fb_regs + HPFB_FBWLSB);
+	fb_info.fix.line_length = fb_width;
+	fb_height = (in_8(fb_regs + HPFB_FBHMSB) << 8) | in_8(fb_regs + HPFB_FBHLSB);
+	fb_info.fix.smem_len = fb_width * fb_height;
+	fb_start = (unsigned long)ioremap_writethrough(fb_info.fix.smem_start,
+						       fb_info.fix.smem_len);
+	hpfb_defined.xres = (in_8(fb_regs + HPFB_DWMSB) << 8) | in_8(fb_regs + HPFB_DWLSB);
+	hpfb_defined.yres = (in_8(fb_regs + HPFB_DHMSB) << 8) | in_8(fb_regs + HPFB_DHLSB);
+	hpfb_defined.xres_virtual = hpfb_defined.xres;
+	hpfb_defined.yres_virtual = hpfb_defined.yres;
+	hpfb_defined.bits_per_pixel = in_8(fb_regs + HPFB_NUMPLANES);
+
+	printk(KERN_INFO "hpfb: framebuffer at 0x%lx, mapped to 0x%lx, size %dk\n",
+	       fb_info.fix.smem_start, fb_start, fb_info.fix.smem_len/1024);
+	printk(KERN_INFO "hpfb: mode is %dx%dx%d, linelength=%d\n",
+	       hpfb_defined.xres, hpfb_defined.yres, hpfb_defined.bits_per_pixel, fb_info.fix.line_length);
 
-	hpfb_fix.smem_start = 0xf0000000 | (in_8(base + fboff) << 16);
-	fb_regs = base;
-
-#if 0
-	/* This is the magic incantation NetBSD uses to make Catseye boards work. */
-	out_8(base+0x4800, 0);
-	out_8(base+0x4510, 0);
-	out_8(base+0x4512, 0);
-	out_8(base+0x4514, 0);
-	out_8(base+0x4516, 0);
-	out_8(base+0x4206, 0x90);
-#endif
-	/* 
+	/*
 	 *	Give the hardware a bit of a prod and work out how many bits per
 	 *	pixel are supported.
 	 */
-	
-	out_8(base + TC_WEN, 0xff);
-	out_8(base + TC_FBEN, 0xff);
-	out_8(hpfb_fix.smem_start, 0xff);
-	fb_bitmask = in_8(hpfb_fix.smem_start);
+	out_8(fb_regs + TC_WEN, 0xff);
+	out_8(fb_regs + TC_PRR, RR_COPY);
+	out_8(fb_regs + TC_FBEN, 0xff);
+	out_8(fb_start, 0xff);
+	fb_bitmask = in_8(fb_start);
+	out_8(fb_start, 0);
 
 	/*
 	 *	Enable reading/writing of all the planes.
 	 */
-	out_8(base + TC_WEN, fb_bitmask);
-	out_8(base + TC_REN, fb_bitmask);
-	out_8(base + TC_FBEN, fb_bitmask);
-	out_8(base + TC_NBLANK, 0x1);
+	out_8(fb_regs + TC_WEN, fb_bitmask);
+	out_8(fb_regs + TC_PRR, RR_COPY);
+	out_8(fb_regs + TC_REN, fb_bitmask);
+	out_8(fb_regs + TC_FBEN, fb_bitmask);
+
+	/*
+	 *	Clear the screen.
+	 */
+	topcat_blit(0, 0, 0, 0, fb_width, fb_height, RR_CLEAR);
 
 	/*
 	 *	Let there be consoles..
 	 */
+	if (DIO_SECID(fb_regs) == DIO_ID2_TOPCAT)
+		strcat(fb_info.fix.id, "Topcat");
+	else
+		strcat(fb_info.fix.id, "Catseye");
 	fb_info.fbops = &hpfb_ops;
 	fb_info.flags = FBINFO_FLAG_DEFAULT;
 	fb_info.var   = hpfb_defined;
-	fb_info.fix   = hpfb_fix;
-	fb_info.screen_base = (char *)hpfb_fix.smem_start;	// FIXME
+	fb_info.screen_base = (char *)fb_start;
 
-	fb_alloc_cmap(&fb_info.cmap, 256, 0);
+	fb_alloc_cmap(&fb_info.cmap, 1 << hpfb_defined.bits_per_pixel, 0);
 
 	if (register_framebuffer(&fb_info) < 0)
+	{
+		fb_dealloc_cmap(&fb_info.cmap);
 		return 1;
+	}
+
+	printk(KERN_INFO "fb%d: %s frame buffer device\n",
+	       fb_info.node, fb_info.fix.id);
+
 	return 0;
 }
 
@@ -178,36 +326,79 @@
 int __init hpfb_init(void)
 {
 	unsigned int sid;
+	mm_segment_t fs;
+	unsigned char i;
+	int err;
 
 	/* Topcats can be on the internal IO bus or real DIO devices.
-	 * The internal variant sits at 0xf0560000; it has primary
+	 * The internal variant sits at 0x560000; it has primary
 	 * and secondary ID registers just like the DIO version.
 	 * So we merge the two detection routines.
 	 *
 	 * Perhaps this #define should be in a global header file:
 	 * I believe it's common to all internal fbs, not just topcat.
 	 */
-#define INTFBADDR 0xf0560000
+#define INTFBVADDR 0xf0560000
+#define INTFBPADDR 0x560000
+
+	if (!MACH_IS_HP300)
+		return -ENXIO;
 
-	if (hwreg_present((void *)INTFBADDR) && 
-	   (DIO_ID(INTFBADDR) == DIO_ID_FBUFFER) &&
-	    topcat_sid_ok(sid = DIO_SECID(INTFBADDR))) {
-		printk("Internal Topcat found (secondary id %02x)\n", sid); 
-		hpfb_init_one(INTFBADDR);
-	} else {
-		int sc = dio_find(DIO_ID_FBUFFER);
-
-		if (sc) {
-			unsigned long addr = (unsigned long)dio_scodetoviraddr(sc);
-			unsigned int sid = DIO_SECID(addr);
-
-			if (topcat_sid_ok(sid)) {
-				printk("Topcat found at DIO select code %02x "
-					"(secondary id %02x)\n", sc, sid);
-				hpfb_init_one(addr);
-			}
+	fs = get_fs();
+	set_fs(KERNEL_DS);
+	err = get_user(i, (unsigned char *)INTFBVADDR + DIO_IDOFF);
+	set_fs(fs);
+
+	if (!err && (i == DIO_ID_FBUFFER) && topcat_sid_ok(sid = DIO_SECID(INTFBVADDR)))
+	{
+		printk(KERN_INFO "Internal Topcat found (secondary id %02x)\n", sid);
+		if (hpfb_init_one(INTFBPADDR, INTFBVADDR))
+		{
+			return -ENOMEM;
 		}
 	}
+	else
+	{
+		int sc, size;
+		unsigned long paddr, vaddr;
+
+		if ((sc = dio_find(DIO_ENCODE_ID(DIO_ID_FBUFFER, DIO_ID2_LRCATSEYE))) < 0 &&
+		    (sc = dio_find(DIO_ENCODE_ID(DIO_ID_FBUFFER, DIO_ID2_HRCCATSEYE))) < 0 &&
+		    (sc = dio_find(DIO_ENCODE_ID(DIO_ID_FBUFFER, DIO_ID2_HRMCATSEYE))) < 0 &&
+		    (sc = dio_find(DIO_ENCODE_ID(DIO_ID_FBUFFER, DIO_ID2_TOPCAT))) < 0)
+		{
+			return -ENXIO;
+		}
+
+		dio_config_board(sc);
+		paddr = dio_scodetophysaddr(sc);
+
+		if (sc >= DIOII_SCBASE)
+		{
+			/* To find out the real size of the device we first need to map it. */
+			vaddr = (unsigned long)ioremap(paddr, PAGE_SIZE);
+			size = DIO_SIZE(sc, vaddr);
+			iounmap((void *)vaddr);
+			vaddr = (unsigned long)ioremap(paddr, size);
+		}
+		else
+		{
+			vaddr = paddr + DIO_VIRADDRBASE;
+			size = DIO_SIZE(sc, vaddr);
+		}
+		sid = DIO_SECID(vaddr);
+
+		printk(KERN_INFO "Topcat found at DIO select code %d "
+		       "(secondary id %02x)\n", sc, sid);
+		if (hpfb_init_one(paddr, vaddr))
+		{
+			if (sc >= DIOII_SCBASE)
+				iounmap((void *)vaddr);
+			dio_unconfig_board(sc);
+			return -ENOMEM;
+		}
+	}
+
 	return 0;
 }
 
diff -Naur linux-2.6.8.1/fs/binfmt_aout.c linux-2.6.8.1-m68k-20040817/fs/binfmt_aout.c
--- linux-2.6.8.1/fs/binfmt_aout.c	2004-08-14 20:54:51.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/fs/binfmt_aout.c	2004-08-16 01:24:30.000000000 +1000
@@ -355,8 +355,9 @@
 			send_sig(SIGKILL, current, 0);
 			return error;
 		}
-			 
-		flush_icache_range(text_addr, text_addr+ex.a_text+ex.a_data);
+
+		flush_icache_user_range((void *)text_addr,
+					ex.a_text + ex.a_data);
 	} else {
 		static unsigned long error_time, error_time2;
 		if ((ex.a_text & 0xfff || ex.a_data & 0xfff) &&
@@ -381,9 +382,8 @@
 			bprm->file->f_op->read(bprm->file,
 					(char __user *)N_TXTADDR(ex),
 					ex.a_text+ex.a_data, &pos);
-			flush_icache_range((unsigned long) N_TXTADDR(ex),
-					   (unsigned long) N_TXTADDR(ex) +
-					   ex.a_text+ex.a_data);
+			flush_icache_user_range((void *)N_TXTADDR(ex),
+						ex.a_text + ex.a_data);
 			goto beyond_if;
 		}
 
@@ -483,8 +483,8 @@
 		
 		file->f_op->read(file, (char __user *)start_addr,
 			ex.a_text + ex.a_data, &pos);
-		flush_icache_range((unsigned long) start_addr,
-				   (unsigned long) start_addr + ex.a_text + ex.a_data);
+		flush_icache_user_range((void *)start_addr,
+					ex.a_text + ex.a_data);
 
 		retval = 0;
 		goto out;
diff -Naur linux-2.6.8.1/fs/binfmt_elf.c linux-2.6.8.1-m68k-20040817/fs/binfmt_elf.c
--- linux-2.6.8.1/fs/binfmt_elf.c	2004-08-14 20:55:23.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/fs/binfmt_elf.c	2004-08-16 01:24:30.000000000 +1000
@@ -449,8 +449,7 @@
 		goto out;
 	if (interpreter->f_op->read(interpreter, addr, text_data, &offset) < 0)
 		goto out;
-	flush_icache_range((unsigned long)addr,
-	                   (unsigned long)addr + text_data);
+	flush_icache_user_range(addr, text_data);
 
 	do_brk(ELF_PAGESTART(text_data + ELF_MIN_ALIGN - 1),
 		interp_ex->a_bss);
diff -Naur linux-2.6.8.1/fs/fat/inode.c linux-2.6.8.1-m68k-20040817/fs/fat/inode.c
--- linux-2.6.8.1/fs/fat/inode.c	2004-08-14 20:55:22.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/fs/fat/inode.c	2004-08-16 01:24:30.000000000 +1000
@@ -11,11 +11,13 @@
  */
 
 #include <linux/module.h>
+#include <linux/config.h>
 #include <linux/time.h>
 #include <linux/slab.h>
 #include <linux/smp_lock.h>
 #include <linux/seq_file.h>
 #include <linux/msdos_fs.h>
+#include <linux/major.h>
 #include <linux/pagemap.h>
 #include <linux/buffer_head.h>
 #include <linux/mount.h>
@@ -255,7 +257,7 @@
 	Opt_check_n, Opt_check_r, Opt_check_s, Opt_uid, Opt_gid,
 	Opt_umask, Opt_dmask, Opt_fmask, Opt_codepage, Opt_nocase,
 	Opt_quiet, Opt_showexec, Opt_debug, Opt_immutable,
-	Opt_dots, Opt_nodots,
+	Opt_dots, Opt_nodots, Opt_atari_no, Opt_atari_yes,
 	Opt_charset, Opt_shortname_lower, Opt_shortname_win95,
 	Opt_shortname_winnt, Opt_shortname_mixed, Opt_utf8_no, Opt_utf8_yes,
 	Opt_uni_xl_no, Opt_uni_xl_yes, Opt_nonumtail_no, Opt_nonumtail_yes,
@@ -280,6 +282,9 @@
 	{Opt_showexec, "showexec"},
 	{Opt_debug, "debug"},
 	{Opt_immutable, "sys_immutable"},
+	{Opt_atari_yes, "atari=yes"},
+	{Opt_atari_yes, "atari"},
+	{Opt_atari_no, "atari=no"},
 	{Opt_obsolate, "conv=binary"},
 	{Opt_obsolate, "conv=text"},
 	{Opt_obsolate, "conv=auto"},
@@ -354,6 +359,13 @@
 	opts->utf8 = opts->unicode_xlate = 0;
 	opts->numtail = 1;
 	opts->nocase = 0;
+	opts->atari = 0;
+
+#ifdef CONFIG_ATARI
+	if(MACH_IS_ATARI)
+	/* make Atari GEMDOS format the default if machine is an Atari */
+		opts->atari = 1;
+#endif
 	*debug = 0;
 
 	if (!options)
@@ -402,6 +414,12 @@
 		case Opt_immutable:
 			opts->sys_immutable = 1;
 			break;
+		case Opt_atari_yes:
+			opts->atari = 1;
+			break;
+		case Opt_atari_no:
+			opts->atari = 0;
+			break;
 		case Opt_uid:
 			if (match_int(&args[0], &option))
 				return 0;
@@ -975,8 +993,31 @@
 
 	total_clusters = (total_sectors - sbi->data_start) / sbi->sec_per_clus;
 
-	if (sbi->fat_bits != 32)
-		sbi->fat_bits = (total_clusters > MAX_FAT12) ? 16 : 12;
+	if (!sbi->options.atari) {
+		if (sbi->fat_bits != 32)
+			sbi->fat_bits = (total_clusters > MAX_FAT12) ? 16 : 12;
+	} else {
+		int sectors;
+		/* Atari GEMDOS partitions always have 16-bit fat */
+		if (sbi->fat_bits != 32)
+			sbi->fat_bits = 16;
+		/* If more clusters than fat entries in 16-bit fat, we assume
+		 * it's a real MSDOS partition with 12-bit fat.
+		 */
+		if (sbi->fat_bits != 32 && total_clusters+2 > sbi->
+			fat_length*SECTOR_SIZE*8/sbi->fat_bits)
+			sbi->fat_bits = 12;
+		/* if it's a floppy disk --> 12bit fat */
+		if (sbi->fat_bits != 32 && MAJOR(sb->s_dev) == FLOPPY_MAJOR)
+			sbi->fat_bits = 12;
+		/* if it's a ramdisk or loopback device and has one of the usual
+		 * floppy sizes -> 12bit FAT  */
+		sectors = total_sectors + sbi->data_start;
+		if (sbi->fat_bits != 32 && (MAJOR(sb->s_dev) == RAMDISK_MAJOR ||
+			 MAJOR(sb->s_dev) == LOOP_MAJOR) &&
+			(sectors == 720 || sectors == 1440 || sectors == 2880))
+			sbi->fat_bits = 12;
+	}
 
 	/* check that FAT table does not overflow */
 	fat_clusters = sbi->fat_length * sb->s_blocksize * 8 / sbi->fat_bits;
diff -Naur linux-2.6.8.1/include/asm-m68k/blinken.h linux-2.6.8.1-m68k-20040817/include/asm-m68k/blinken.h
--- linux-2.6.8.1/include/asm-m68k/blinken.h	2004-08-14 20:54:49.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/include/asm-m68k/blinken.h	2004-07-10 06:52:30.000000000 +1000
@@ -13,15 +13,20 @@
 #define _M68K_BLINKEN_H
 
 #include <asm/setup.h>
+#include <asm/io.h>
 
 #define HP300_LEDS		0xf001ffff
 
-static __inline__ void blinken_leds(int x)
+extern unsigned char ledstate;
+
+static __inline__ void blinken_leds(int on, int off)
 {
-  if (MACH_IS_HP300)
-  {
-    *((volatile unsigned char *)HP300_LEDS) = (x);
-  }
+	if (MACH_IS_HP300)
+	{
+		ledstate |= on;
+		ledstate &= ~off;
+		out_8(HP300_LEDS, ~ledstate);
+	}
 }
 
 #endif
diff -Naur linux-2.6.8.1/include/asm-m68k/bootinfo.h linux-2.6.8.1-m68k-20040817/include/asm-m68k/bootinfo.h
--- linux-2.6.8.1/include/asm-m68k/bootinfo.h	2004-08-14 20:55:35.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/include/asm-m68k/bootinfo.h	2004-07-10 06:52:30.000000000 +1000
@@ -213,7 +213,13 @@
 
 #define BI_APOLLO_MODEL         0x8000  /* model (u_long) */
 
+    /*
+     *  HP300-specific tags
+     */
 
+#define BI_HP300_MODEL		0x8000	/* model (u_long) */
+#define BI_HP300_UART_SCODE	0x8001	/* UART select code (u_long) */
+#define BI_HP300_UART_ADDR	0x8002	/* phys. addr of UART (u_long) */
 
     /*
      * Stuff for bootinfo interface versioning
@@ -255,6 +261,7 @@
 #define MVME16x_BOOTI_VERSION  MK_BI_VERSION( 2, 0 )
 #define BVME6000_BOOTI_VERSION MK_BI_VERSION( 2, 0 )
 #define Q40_BOOTI_VERSION      MK_BI_VERSION( 2, 0 )
+#define HP300_BOOTI_VERSION    MK_BI_VERSION( 2, 0 )
 
 #ifdef BOOTINFO_COMPAT_1_0
 
diff -Naur linux-2.6.8.1/include/asm-m68k/cacheflush.h linux-2.6.8.1-m68k-20040817/include/asm-m68k/cacheflush.h
--- linux-2.6.8.1/include/asm-m68k/cacheflush.h	2004-08-14 20:55:35.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/include/asm-m68k/cacheflush.h	2004-06-17 07:16:53.000000000 +1000
@@ -131,12 +131,24 @@
 #define flush_dcache_mmap_lock(mapping)		do { } while (0)
 #define flush_dcache_mmap_unlock(mapping)	do { } while (0)
 #define flush_icache_page(vma, page)	__flush_page_to_ram(page_address(page))
-#define flush_icache_user_range(vma,pg,adr,len)	do { } while (0)
-#define copy_to_user_page(vma, page, vaddr, dst, src, len) \
-	memcpy(dst, src, len)
-#define copy_from_user_page(vma, page, vaddr, dst, src, len) \
-	memcpy(dst, src, len)
 
+extern void flush_icache_user_page(struct vm_area_struct *vma, struct page *page,
+				   unsigned long addr, int len);
 extern void flush_icache_range(unsigned long address, unsigned long endaddr);
+extern void flush_icache_user_range(void *address, unsigned long size);
+
+static inline void copy_to_user_page(struct vm_area_struct *vma,
+				     struct page *page, unsigned long vaddr,
+				     void *dst, void *src, int len)
+{
+	memcpy(dst, src, len);
+	flush_icache_user_page(vma, page, vaddr, len);
+}
+static inline void copy_from_user_page(struct vm_area_struct *vma,
+				       struct page *page, unsigned long vaddr,
+				       void *dst, void *src, int len)
+{
+	memcpy(dst, src, len);
+}
 
 #endif /* _M68K_CACHEFLUSH_H */
diff -Naur linux-2.6.8.1/include/asm-m68k/hp300hw.h linux-2.6.8.1-m68k-20040817/include/asm-m68k/hp300hw.h
--- linux-2.6.8.1/include/asm-m68k/hp300hw.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/include/asm-m68k/hp300hw.h	2004-07-10 06:52:30.000000000 +1000
@@ -0,0 +1,25 @@
+#ifndef _M68K_HP300HW_H
+#define _M68K_HP300HW_H
+
+extern unsigned long hp300_model;
+
+/* This information was taken from NetBSD */
+#define	HP_320		(0)	/* 16MHz 68020+HP MMU+16K external cache */
+#define	HP_330		(1)	/* 16MHz 68020+68851 MMU */
+#define	HP_340		(2)	/* 16MHz 68030 */
+#define	HP_345		(3)	/* 50MHz 68030+32K external cache */
+#define	HP_350		(4)	/* 25MHz 68020+HP MMU+32K external cache */
+#define	HP_360		(5)	/* 25MHz 68030 */
+#define	HP_370		(6)	/* 33MHz 68030+64K external cache */
+#define	HP_375		(7)	/* 50MHz 68030+32K external cache */
+#define	HP_380		(8)	/* 25MHz 68040 */
+#define	HP_385		(9)	/* 33MHz 68040 */
+
+#define	HP_400		(10)	/* 50MHz 68030+32K external cache */
+#define	HP_425T		(11)	/* 25MHz 68040 - model 425t */
+#define	HP_425S		(12)	/* 25MHz 68040 - model 425s */
+#define HP_425E		(13)	/* 25MHz 68040 - model 425e */
+#define HP_433T		(14)	/* 33MHz 68040 - model 433t */
+#define HP_433S		(15)	/* 33MHz 68040 - model 433s */
+
+#endif /* _M68K_HP300HW_H */
diff -Naur linux-2.6.8.1/include/asm-m68k/io.h linux-2.6.8.1-m68k-20040817/include/asm-m68k/io.h
--- linux-2.6.8.1/include/asm-m68k/io.h	2004-08-14 20:55:35.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/include/asm-m68k/io.h	2004-07-12 02:00:33.000000000 +1000
@@ -306,6 +306,21 @@
 #endif
 #endif /* CONFIG_PCI */
 
+#if !defined(CONFIG_ISA) && !defined(CONFIG_PCI) && defined(CONFIG_HP300)
+/*
+ * We need to define dummy functions otherwise drivers/serial/8250.c doesn't link
+ */
+#define inb(port)        0xff
+#define inb_p(port)      0xff
+#define outb(val,port)   do { } while (0)
+#define outb_p(val,port) do { } while (0)
+
+/*
+ * These should be valid on any ioremap()ed region
+ */
+#define readb(addr)      in_8(addr)
+#define writeb(val,addr) out_8((addr),(val))
+#endif
 
 static inline void *ioremap(unsigned long physaddr, unsigned long size)
 {
diff -Naur linux-2.6.8.1/include/asm-m68k/processor.h linux-2.6.8.1-m68k-20040817/include/asm-m68k/processor.h
--- linux-2.6.8.1/include/asm-m68k/processor.h	2004-08-14 20:55:48.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/include/asm-m68k/processor.h	2004-02-02 07:03:16.000000000 +1100
@@ -14,6 +14,7 @@
 #define current_text_addr() ({ __label__ _l; _l: &&_l;})
 
 #include <linux/config.h>
+#include <linux/thread_info.h>
 #include <asm/segment.h>
 #include <asm/fpu.h>
 #include <asm/ptrace.h>
@@ -78,6 +79,7 @@
 	unsigned long  fpcntl[3];	/* fp control regs */
 	unsigned char  fpstate[FPSTATESIZE];  /* floating point state */
 	struct task_work work;
+	struct thread_info info;
 };
 
 #define INIT_THREAD  {							\
diff -Naur linux-2.6.8.1/include/asm-m68k/serial.h linux-2.6.8.1-m68k-20040817/include/asm-m68k/serial.h
--- linux-2.6.8.1/include/asm-m68k/serial.h	2004-08-14 20:56:00.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/include/asm-m68k/serial.h	2004-07-12 02:02:36.000000000 +1000
@@ -74,6 +74,8 @@
 #define EXTRA_SERIAL_PORT_DEFNS
 #endif
 
+#ifdef CONFIG_ISA
 #define SERIAL_PORT_DFNS		\
 	STD_SERIAL_PORT_DEFNS		\
 	EXTRA_SERIAL_PORT_DEFNS
+#endif
diff -Naur linux-2.6.8.1/include/asm-m68k/thread_info.h linux-2.6.8.1-m68k-20040817/include/asm-m68k/thread_info.h
--- linux-2.6.8.1/include/asm-m68k/thread_info.h	2004-08-14 20:55:35.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/include/asm-m68k/thread_info.h	2004-04-05 23:09:08.000000000 +1000
@@ -2,7 +2,6 @@
 #define _ASM_M68K_THREAD_INFO_H
 
 #include <asm/types.h>
-#include <asm/processor.h>
 #include <asm/page.h>
 
 struct thread_info {
@@ -28,18 +27,21 @@
 
 /* THREAD_SIZE should be 8k, so handle differently for 4k and 8k machines */
 #if PAGE_SHIFT == 13 /* 8k machines */
-#define alloc_thread_info(tsk)   ((struct thread_info *)__get_free_pages(GFP_KERNEL,0))
-#define free_thread_info(ti)  free_pages((unsigned long)(ti),0)
+#define alloc_thread_stack(tsk) ((void *)__get_free_pages(GFP_KERNEL,0))
+#define free_thread_stack(ti)  free_pages((unsigned long)(ti),0)
 #else /* otherwise assume 4k pages */
-#define alloc_thread_info(tsk)   ((struct thread_info *)__get_free_pages(GFP_KERNEL,1))
-#define free_thread_info(ti)  free_pages((unsigned long)(ti),1)
+#define alloc_thread_stack(tsk) ((void *)__get_free_pages(GFP_KERNEL,1))
+#define free_thread_stack(ti)  free_pages((unsigned long)(ti),1)
 #endif /* PAGE_SHIFT == 13 */
 
 //#define init_thread_info	(init_task.thread.info)
 #define init_stack		(init_thread_union.stack)
 
-#define current_thread_info()	(current->thread_info)
+#define get_thread_info(tsk)	(&(tsk)->thread.info)
+#define current_thread_info()	get_thread_info(current)
 
+#define initialize_thread_info(org, new) \
+	(*(struct task_struct **)(new)->stack = (new));
 
 #define __HAVE_THREAD_FUNCTIONS
 
diff -Naur linux-2.6.8.1/include/linux/adb.h linux-2.6.8.1-m68k-20040817/include/linux/adb.h
--- linux-2.6.8.1/include/linux/adb.h	2004-08-14 20:56:23.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/include/linux/adb.h	2003-03-26 06:25:16.000000000 +1100
@@ -76,6 +76,7 @@
 #define ADBREQ_REPLY	1	/* expect reply */
 #define ADBREQ_SYNC	2	/* poll until done */
 #define ADBREQ_NOSEND	4	/* build the request, but don't send it */
+#define ADBREQ_RAW	8	/* send raw packet (don't prepend ADB_PACKET) */
 
 /* Messages sent thru the client_list notifier. You should NOT stop
    the operation, at least not with this version */
diff -Naur linux-2.6.8.1/include/linux/bootmem.h linux-2.6.8.1-m68k-20040817/include/linux/bootmem.h
--- linux-2.6.8.1/include/linux/bootmem.h	2004-08-14 20:56:01.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/include/linux/bootmem.h	2004-08-16 01:24:46.000000000 +1000
@@ -45,11 +45,11 @@
 #define alloc_bootmem(x) \
 	__alloc_bootmem((x), SMP_CACHE_BYTES, __pa(MAX_DMA_ADDRESS))
 #define alloc_bootmem_low(x) \
-	__alloc_bootmem((x), SMP_CACHE_BYTES, 0)
+	__alloc_bootmem((x), SMP_CACHE_BYTES, __pa(PAGE_OFFSET))
 #define alloc_bootmem_pages(x) \
 	__alloc_bootmem((x), PAGE_SIZE, __pa(MAX_DMA_ADDRESS))
 #define alloc_bootmem_low_pages(x) \
-	__alloc_bootmem((x), PAGE_SIZE, 0)
+	__alloc_bootmem((x), PAGE_SIZE, __pa(PAGE_OFFSET))
 #endif /* !CONFIG_HAVE_ARCH_BOOTMEM_NODE */
 extern unsigned long __init free_all_bootmem (void);
 
diff -Naur linux-2.6.8.1/include/linux/dio.h linux-2.6.8.1-m68k-20040817/include/linux/dio.h
--- linux-2.6.8.1/include/linux/dio.h	2004-08-14 20:56:22.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/include/linux/dio.h	2004-07-16 06:07:31.000000000 +1000
@@ -28,6 +28,9 @@
  * do with ioremap() though.
  */
 #ifdef __KERNEL__
+
+#include <asm/hp300hw.h>
+
 /* DIO/DIO-II boards all have the following 8bit registers.
  * These are offsets from the base of the device.
  */
@@ -35,26 +38,7 @@
 #define DIO_IPLOFF    0x03                        /* interrupt priority level */
 #define DIO_SECIDOFF  0x15                        /* secondary device ID */
 #define DIOII_SIZEOFF 0x101                       /* device size, DIO-II only */
-
-/* The internal HPIB device is special; this is its physaddr; its select code is 7. 
- * The reason why we have to treat it specially is because apparently it's broken:
- * the device ID isn't consistent/reliable. *sigh*
- */
-#define DIO_IHPIBADDR 0x47800
-#define DIO_IHPIBSCODE 7
-
-/* If we don't have the internal HPIB defined, then treat select code 7 like
- * any other. If we *do* have internal HPIB, then we just have to assume that
- * select code 7 is the internal HPIB regardless of the ID register :-<
- */
-#define CONFIG_IHPIB /* hack hack : not yet a proper config option */
-#ifdef CONFIG_IHPIB
-#define DIO_ISIHPIB(scode) ((scode) == DIO_IHPIBSCODE)
-#else
-#define DIO_ISIHPIB(scode) 0
-#endif
-
-#define DIO_VIRADDRBASE 0xf0000000                /* vir addr where IOspace is mapped */
+#define DIO_VIRADDRBASE 0xf0000000UL              /* vir addr where IOspace is mapped */
 
 #define DIO_BASE                0x600000        /* start of DIO space */
 #define DIO_END                 0x1000000       /* end of DIO space */
@@ -67,9 +51,10 @@
 /* Highest valid select code. If we add DIO-II support this should become
  * 256 for everything except HP320, which only has DIO.
  */
-#define DIO_SCMAX 32                             
+#define DIO_SCMAX (hp300_model == HP_320 ? 32 : 256)
 #define DIOII_SCBASE 132 /* lowest DIO-II select code */
 #define DIO_SCINHOLE(scode) (((scode) >= 32) && ((scode) < DIOII_SCBASE))
+#define DIO_ISDIOII(scode) ((scode) >= 132 && (scode) < 256)
 
 /* macros to read device IDs, given base address */
 #define DIO_ID(baseaddr) in_8((baseaddr) + DIO_IDOFF)
@@ -91,7 +76,7 @@
  * In practice this is only important for framebuffers,
  * and everybody else just sets ID fields equal to the DIO_ID_FOO value.
  */
-#define DIO_ENCODE_ID(pr,sec) ((((int)sec & 0xff) << 8) & ((int)pr & 0xff))
+#define DIO_ENCODE_ID(pr,sec) ((((int)sec & 0xff) << 8) | ((int)pr & 0xff))
 /* macro to determine whether a given primary ID requires a secondary ID byte */
 #define DIO_NEEDSSECID(id) ((id) == DIO_ID_FBUFFER)
 
@@ -112,10 +97,8 @@
 #define DIO_DESC_LAN "98643A LANCE ethernet"
 #define DIO_ID_FHPIB    0x08 /* 98625A/98625B fast HP-IB */
 #define DIO_DESC_FHPIB "98625A/98625B fast HPIB"
-#define DIO_ID_NHPIB    0x80 /* 98624A HP-IB (normal ie slow) */
+#define DIO_ID_NHPIB    0x01 /* 98624A HP-IB (normal ie slow) */
 #define DIO_DESC_NHPIB "98624A HPIB"
-#define DIO_ID_IHPIB    0x00 /* internal HPIB (not its real ID, it hasn't got one! */
-#define DIO_DESC_IHPIB "internal HPIB"
 #define DIO_ID_SCSI0    0x07 /* 98625A SCSI */
 #define DIO_DESC_SCSI0 "98625A SCSI0"
 #define DIO_ID_SCSI1    0x27 /* ditto */
@@ -193,7 +176,7 @@
  */
 
 extern int dio_find(int deviceid);
-extern void *dio_scodetoviraddr(int scode);
+extern unsigned long dio_scodetophysaddr(int scode);
 extern int dio_scodetoipl(int scode);
 extern const char *dio_scodetoname(int scode);
 extern void dio_config_board(int scode);
diff -Naur linux-2.6.8.1/include/linux/ide.h linux-2.6.8.1-m68k-20040817/include/linux/ide.h
--- linux-2.6.8.1/include/linux/ide.h	2004-08-14 20:55:10.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/include/linux/ide.h	2004-08-16 01:24:46.000000000 +1000
@@ -631,7 +631,7 @@
  * sense_key	: Sense key of the last failed packet command
  */
 typedef union {
-	unsigned all			:8;
+	u8 all;
 	struct {
 #if defined(__LITTLE_ENDIAN_BITFIELD)
 		unsigned ili		:1;
diff -Naur linux-2.6.8.1/include/linux/init_task.h linux-2.6.8.1-m68k-20040817/include/linux/init_task.h
--- linux-2.6.8.1/include/linux/init_task.h	2004-08-14 20:54:49.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/include/linux/init_task.h	2004-08-16 01:24:46.000000000 +1000
@@ -67,7 +67,7 @@
 #define INIT_TASK(tsk)	\
 {									\
 	.state		= 0,						\
-	.thread_info	= &init_thread_info,				\
+	.stack		= &init_stack,					\
 	.usage		= ATOMIC_INIT(2),				\
 	.flags		= 0,						\
 	.lock_depth	= -1,						\
diff -Naur linux-2.6.8.1/include/linux/sched.h linux-2.6.8.1-m68k-20040817/include/linux/sched.h
--- linux-2.6.8.1/include/linux/sched.h	2004-08-14 20:54:49.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/include/linux/sched.h	2004-08-16 01:24:46.000000000 +1000
@@ -4,15 +4,14 @@
 #include <asm/param.h>	/* for HZ */
 
 #include <linux/config.h>
-#include <linux/capability.h>
 #include <linux/threads.h>
 #include <linux/kernel.h>
-#include <linux/types.h>
 #include <linux/timex.h>
 #include <linux/jiffies.h>
 #include <linux/rbtree.h>
 #include <linux/thread_info.h>
 #include <linux/cpumask.h>
+#include <linux/task_struct.h>
 
 #include <asm/system.h>
 #include <asm/semaphore.h>
@@ -323,9 +322,6 @@
 extern struct user_struct root_user;
 #define INIT_USER (&root_user)
 
-typedef struct prio_array prio_array_t;
-struct backing_dev_info;
-struct reclaim_state;
 
 /* POSIX.1b interval timer structure. */
 struct k_itimer {
@@ -347,197 +343,24 @@
 	struct timespec wall_to_prev;   /* wall_to_monotonic used when set */
 };
 
-
-struct io_context;			/* See blkdev.h */
 void exit_io_context(void);
 
-#define NGROUPS_SMALL		32
-#define NGROUPS_PER_BLOCK	((int)(PAGE_SIZE / sizeof(gid_t)))
-struct group_info {
-	int ngroups;
-	atomic_t usage;
-	gid_t small_block[NGROUPS_SMALL];
-	int nblocks;
-	gid_t *blocks[0];
-};
-
-/*
- * get_group_info() must be called with the owning task locked (via task_lock())
- * when task != current.  The reason being that the vast majority of callers are
- * looking at current->group_info, which can not be changed except by the
- * current task.  Changing current->group_info requires the task lock, too.
- */
-#define get_group_info(group_info) do { \
-	atomic_inc(&(group_info)->usage); \
-} while (0)
-
-#define put_group_info(group_info) do { \
-	if (atomic_dec_and_test(&(group_info)->usage)) \
-		groups_free(group_info); \
-} while (0)
-
-struct group_info *groups_alloc(int gidsetsize);
-void groups_free(struct group_info *group_info);
-int set_current_groups(struct group_info *group_info);
-/* access the groups "array" with this macro */
-#define GROUP_AT(gi, i) \
-    ((gi)->blocks[(i)/NGROUPS_PER_BLOCK][(i)%NGROUPS_PER_BLOCK])
-
-
-struct audit_context;		/* See audit.c */
-struct mempolicy;
-
-struct task_struct {
-	volatile long state;	/* -1 unrunnable, 0 runnable, >0 stopped */
-	struct thread_info *thread_info;
-	atomic_t usage;
-	unsigned long flags;	/* per process flags, defined below */
-	unsigned long ptrace;
-
-	int lock_depth;		/* Lock depth */
-
-	int prio, static_prio;
-	struct list_head run_list;
-	prio_array_t *array;
-
-	unsigned long sleep_avg;
-	long interactive_credit;
-	unsigned long long timestamp;
-	int activated;
-
-	unsigned long policy;
-	cpumask_t cpus_allowed;
-	unsigned int time_slice, first_time_slice;
-
-	struct list_head tasks;
-	/*
-	 * ptrace_list/ptrace_children forms the list of my children
-	 * that were stolen by a ptracer.
-	 */
-	struct list_head ptrace_children;
-	struct list_head ptrace_list;
-
-	struct mm_struct *mm, *active_mm;
-
-/* task state */
-	struct linux_binfmt *binfmt;
-	int exit_code, exit_signal;
-	int pdeath_signal;  /*  The signal sent when the parent dies  */
-	/* ??? */
-	unsigned long personality;
-	int did_exec:1;
-	pid_t pid;
-	pid_t tgid;
-	/* 
-	 * pointers to (original) parent process, youngest child, younger sibling,
-	 * older sibling, respectively.  (p->father can be replaced with 
-	 * p->parent->pid)
-	 */
-	struct task_struct *real_parent; /* real parent process (when being debugged) */
-	struct task_struct *parent;	/* parent process */
-	/*
-	 * children/sibling forms the list of my children plus the
-	 * tasks I'm ptracing.
-	 */
-	struct list_head children;	/* list of my children */
-	struct list_head sibling;	/* linkage in my parent's children list */
-	struct task_struct *group_leader;	/* threadgroup leader */
-
-	/* PID/PID hash table linkage. */
-	struct pid_link pids[PIDTYPE_MAX];
-
-	wait_queue_head_t wait_chldexit;	/* for wait4() */
-	struct completion *vfork_done;		/* for vfork() */
-	int __user *set_child_tid;		/* CLONE_CHILD_SETTID */
-	int __user *clear_child_tid;		/* CLONE_CHILD_CLEARTID */
-
-	unsigned long rt_priority;
-	unsigned long it_real_value, it_prof_value, it_virt_value;
-	unsigned long it_real_incr, it_prof_incr, it_virt_incr;
-	struct timer_list real_timer;
-	unsigned long utime, stime, cutime, cstime;
-	unsigned long nvcsw, nivcsw, cnvcsw, cnivcsw; /* context switch counts */
-	u64 start_time;
-/* mm fault and swap info: this can arguably be seen as either mm-specific or thread-specific */
-	unsigned long min_flt, maj_flt, cmin_flt, cmaj_flt;
-/* process credentials */
-	uid_t uid,euid,suid,fsuid;
-	gid_t gid,egid,sgid,fsgid;
-	struct group_info *group_info;
-	kernel_cap_t   cap_effective, cap_inheritable, cap_permitted;
-	int keep_capabilities:1;
-	struct user_struct *user;
-/* limits */
-	struct rlimit rlim[RLIM_NLIMITS];
-	unsigned short used_math;
-	char comm[16];
-/* file system info */
-	int link_count, total_link_count;
-/* ipc stuff */
-	struct sysv_sem sysvsem;
-/* CPU-specific state of this task */
-	struct thread_struct thread;
-/* filesystem information */
-	struct fs_struct *fs;
-/* open file information */
-	struct files_struct *files;
-/* namespace */
-	struct namespace *namespace;
-/* signal handlers */
-	struct signal_struct *signal;
-	struct sighand_struct *sighand;
-
-	sigset_t blocked, real_blocked;
-	struct sigpending pending;
-
-	unsigned long sas_ss_sp;
-	size_t sas_ss_size;
-	int (*notifier)(void *priv);
-	void *notifier_data;
-	sigset_t *notifier_mask;
-	
-	void *security;
-	struct audit_context *audit_context;
-
-/* Thread group tracking */
-   	u32 parent_exec_id;
-   	u32 self_exec_id;
-/* Protection of (de-)allocation: mm, files, fs, tty */
-	spinlock_t alloc_lock;
-/* Protection of proc_dentry: nesting proc_lock, dcache_lock, write_lock_irq(&tasklist_lock); */
-	spinlock_t proc_lock;
-/* context-switch lock */
-	spinlock_t switch_lock;
-
-/* journalling filesystem info */
-	void *journal_info;
-
-/* VM state */
-	struct reclaim_state *reclaim_state;
-
-	struct dentry *proc_dentry;
-	struct backing_dev_info *backing_dev_info;
-
-	struct io_context *io_context;
-
-	unsigned long ptrace_message;
-	siginfo_t *last_siginfo; /* For ptrace use.  */
-
-#ifdef CONFIG_NUMA
-  	struct mempolicy *mempolicy;
-  	short il_next;		/* could be shared with used_math */
-#endif
-};
-
 static inline pid_t process_group(struct task_struct *tsk)
 {
 	return tsk->signal->pgrp;
 }
 
 extern void __put_task_struct(struct task_struct *tsk);
-#define get_task_struct(tsk) do { atomic_inc(&(tsk)->usage); } while(0)
-#define put_task_struct(tsk) \
-do { if (atomic_dec_and_test(&(tsk)->usage)) __put_task_struct(tsk); } while(0)
+
+static inline void get_task_struct(struct task_struct *tsk)
+{
+	atomic_inc(&tsk->usage);        
+}
+static inline void put_task_struct(struct task_struct *tsk)
+{
+	if (atomic_dec_and_test(&tsk->usage)) 
+		__put_task_struct(tsk);
+}
 
 /*
  * Per process flags
@@ -981,6 +804,8 @@
 /* set thread flags in other task's structures
  * - see asm/thread_info.h for TIF_xxxx flags available
  */
+#ifndef __HAVE_THREAD_FUNCTIONS
+
 static inline void set_tsk_thread_flag(struct task_struct *tsk, int flag)
 {
 	set_ti_thread_flag(tsk->thread_info,flag);
@@ -1005,6 +830,7 @@
 {
 	return test_ti_thread_flag(tsk->thread_info,flag);
 }
+#endif	/* __HAVE_THREAD_FUNCTIONS */
 
 static inline void set_tsk_need_resched(struct task_struct *tsk)
 {
diff -Naur linux-2.6.8.1/include/linux/task_struct.h linux-2.6.8.1-m68k-20040817/include/linux/task_struct.h
--- linux-2.6.8.1/include/linux/task_struct.h	1970-01-01 10:00:00.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/include/linux/task_struct.h	2004-08-16 01:24:46.000000000 +1000
@@ -0,0 +1,200 @@
+#ifndef _LINUX_TASK_STRUCT_H
+#define _LINUX_TASK_STRUCT_H
+
+#include <linux/capability.h>
+#include <linux/list.h>
+#include <linux/resource.h>
+#include <linux/sem.h>
+#include <linux/signal.h>
+#include <linux/pid.h>
+#include <linux/timer.h>
+#include <linux/threads.h>
+#include <linux/types.h>
+#include <linux/wait.h>
+#include <asm/atomic.h>
+#include <asm/param.h>
+
+typedef struct prio_array prio_array_t;
+struct backing_dev_info;
+struct reclaim_state;
+struct io_context;			/* See blkdev.h */
+struct audit_context;			/* See audit.c */
+struct mempolicy;
+
+#define NGROUPS_SMALL		32
+#define NGROUPS_PER_BLOCK	((int)(PAGE_SIZE / sizeof(gid_t)))
+struct group_info {
+	int ngroups;
+	atomic_t usage;
+	gid_t small_block[NGROUPS_SMALL];
+	int nblocks;
+	gid_t *blocks[0];
+};
+
+/*
+ * get_group_info() must be called with the owning task locked (via task_lock())
+ * when task != current.  The reason being that the vast majority of callers are
+ * looking at current->group_info, which can not be changed except by the
+ * current task.  Changing current->group_info requires the task lock, too.
+ */
+#define get_group_info(group_info) do { \
+	atomic_inc(&(group_info)->usage); \
+} while (0)
+
+#define put_group_info(group_info) do { \
+	if (atomic_dec_and_test(&(group_info)->usage)) \
+		groups_free(group_info); \
+} while (0)
+
+struct group_info *groups_alloc(int gidsetsize);
+void groups_free(struct group_info *group_info);
+int set_current_groups(struct group_info *group_info);
+/* access the groups "array" with this macro */
+#define GROUP_AT(gi, i) \
+    ((gi)->blocks[(i)/NGROUPS_PER_BLOCK][(i)%NGROUPS_PER_BLOCK])
+
+
+struct task_struct {
+	volatile long state;	/* -1 unrunnable, 0 runnable, >0 stopped */
+	//struct thread_info *thread_info;
+	void *stack;
+	atomic_t usage;
+	unsigned long flags;	/* per process flags, defined below */
+	unsigned long ptrace;
+
+	int lock_depth;		/* Lock depth */
+
+	int prio, static_prio;
+	struct list_head run_list;
+	prio_array_t *array;
+
+	unsigned long sleep_avg;
+	long interactive_credit;
+	unsigned long long timestamp;
+	int activated;
+
+	unsigned long policy;
+	cpumask_t cpus_allowed;
+	unsigned int time_slice, first_time_slice;
+
+	struct list_head tasks;
+	/*
+	 * ptrace_list/ptrace_children forms the list of my children
+	 * that were stolen by a ptracer.
+	 */
+	struct list_head ptrace_children;
+	struct list_head ptrace_list;
+
+	struct mm_struct *mm, *active_mm;
+
+/* task state */
+	struct linux_binfmt *binfmt;
+	int exit_code, exit_signal;
+	int pdeath_signal;  /*  The signal sent when the parent dies  */
+	/* ??? */
+	unsigned long personality;
+	int did_exec:1;
+	pid_t pid;
+	pid_t tgid;
+	/* 
+	 * pointers to (original) parent process, youngest child, younger sibling,
+	 * older sibling, respectively.  (p->father can be replaced with 
+	 * p->parent->pid)
+	 */
+	struct task_struct *real_parent; /* real parent process (when being debugged) */
+	struct task_struct *parent;	/* parent process */
+	/*
+	 * children/sibling forms the list of my children plus the
+	 * tasks I'm ptracing.
+	 */
+	struct list_head children;	/* list of my children */
+	struct list_head sibling;	/* linkage in my parent's children list */
+	struct task_struct *group_leader;	/* threadgroup leader */
+
+	/* PID/PID hash table linkage. */
+	struct pid_link pids[PIDTYPE_MAX];
+
+	wait_queue_head_t wait_chldexit;	/* for wait4() */
+	struct completion *vfork_done;		/* for vfork() */
+	int __user *set_child_tid;		/* CLONE_CHILD_SETTID */
+	int __user *clear_child_tid;		/* CLONE_CHILD_CLEARTID */
+
+	unsigned long rt_priority;
+	unsigned long it_real_value, it_prof_value, it_virt_value;
+	unsigned long it_real_incr, it_prof_incr, it_virt_incr;
+	struct timer_list real_timer;
+	unsigned long utime, stime, cutime, cstime;
+	unsigned long nvcsw, nivcsw, cnvcsw, cnivcsw; /* context switch counts */
+	u64 start_time;
+/* mm fault and swap info: this can arguably be seen as either mm-specific or thread-specific */
+	unsigned long min_flt, maj_flt, cmin_flt, cmaj_flt;
+/* process credentials */
+	uid_t uid,euid,suid,fsuid;
+	gid_t gid,egid,sgid,fsgid;
+	struct group_info *group_info;
+	kernel_cap_t   cap_effective, cap_inheritable, cap_permitted;
+	int keep_capabilities:1;
+	struct user_struct *user;
+/* limits */
+	struct rlimit rlim[RLIM_NLIMITS];
+	unsigned short used_math;
+	char comm[16];
+/* file system info */
+	int link_count, total_link_count;
+/* ipc stuff */
+	struct sysv_sem sysvsem;
+/* CPU-specific state of this task */
+	struct thread_struct thread;
+/* filesystem information */
+	struct fs_struct *fs;
+/* open file information */
+	struct files_struct *files;
+/* namespace */
+	struct namespace *namespace;
+/* signal handlers */
+	struct signal_struct *signal;
+	struct sighand_struct *sighand;
+
+	sigset_t blocked, real_blocked;
+	struct sigpending pending;
+
+	unsigned long sas_ss_sp;
+	size_t sas_ss_size;
+	int (*notifier)(void *priv);
+	void *notifier_data;
+	sigset_t *notifier_mask;
+	
+	void *security;
+	struct audit_context *audit_context;
+
+/* Thread group tracking */
+   	u32 parent_exec_id;
+   	u32 self_exec_id;
+/* Protection of (de-)allocation: mm, files, fs, tty */
+	spinlock_t alloc_lock;
+/* Protection of proc_dentry: nesting proc_lock, dcache_lock, write_lock_irq(&tasklist_lock); */
+	spinlock_t proc_lock;
+/* context-switch lock */
+	spinlock_t switch_lock;
+
+/* journalling filesystem info */
+	void *journal_info;
+
+/* VM state */
+	struct reclaim_state *reclaim_state;
+
+	struct dentry *proc_dentry;
+	struct backing_dev_info *backing_dev_info;
+
+	struct io_context *io_context;
+
+	unsigned long ptrace_message;
+	siginfo_t *last_siginfo; /* For ptrace use.  */
+
+#ifdef CONFIG_NUMA
+  	struct mempolicy *mempolicy;
+  	short il_next;		/* could be shared with used_math */
+#endif
+};
+
+#endif /* _LINUX_TASK_STRUCT_H */
diff -Naur linux-2.6.8.1/include/linux/thread_info.h linux-2.6.8.1-m68k-20040817/include/linux/thread_info.h
--- linux-2.6.8.1/include/linux/thread_info.h	2004-08-14 20:56:23.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/include/linux/thread_info.h	2003-03-26 06:25:17.000000000 +1100
@@ -21,6 +21,7 @@
 #include <asm/thread_info.h>
 
 #ifdef __KERNEL__
+#ifndef __HAVE_THREAD_FUNCTIONS
 
 /*
  * flag set/clear/test wrappers
@@ -87,6 +88,7 @@
 	clear_thread_flag(TIF_NEED_RESCHED);
 }
 
-#endif
+#endif	/* __HAVE_THREAD_FUNCTIONS */
+#endif	/* __KERNEL__ */
 
 #endif /* _LINUX_THREAD_INFO_H */
diff -Naur linux-2.6.8.1/kernel/exit.c linux-2.6.8.1-m68k-20040817/kernel/exit.c
--- linux-2.6.8.1/kernel/exit.c	2004-08-14 20:56:01.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/kernel/exit.c	2004-08-16 01:24:47.000000000 +1000
@@ -832,7 +832,7 @@
 	if (tsk->signal->leader)
 		disassociate_ctty(1);
 
-	module_put(tsk->thread_info->exec_domain->module);
+	module_put(get_thread_info(tsk)->exec_domain->module);
 	if (tsk->binfmt)
 		module_put(tsk->binfmt->module);
 
diff -Naur linux-2.6.8.1/kernel/fork.c linux-2.6.8.1-m68k-20040817/kernel/fork.c
--- linux-2.6.8.1/kernel/fork.c	2004-08-14 20:54:49.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/kernel/fork.c	2004-08-16 01:24:47.000000000 +1000
@@ -77,7 +77,7 @@
 
 static void free_task(struct task_struct *tsk)
 {
-	free_thread_info(tsk->thread_info);
+	free_thread_stack(tsk->stack);
 	free_task_struct(tsk);
 }
 
@@ -241,7 +241,7 @@
 static struct task_struct *dup_task_struct(struct task_struct *orig)
 {
 	struct task_struct *tsk;
-	struct thread_info *ti;
+	void *stack;
 
 	prepare_to_copy(orig);
 
@@ -249,16 +249,17 @@
 	if (!tsk)
 		return NULL;
 
-	ti = alloc_thread_info(tsk);
-	if (!ti) {
+	stack = alloc_thread_stack(tsk);
+	if (!stack) {
 		free_task_struct(tsk);
 		return NULL;
 	}
 
-	*ti = *orig->thread_info;
 	*tsk = *orig;
-	tsk->thread_info = ti;
-	ti->task = tsk;
+	tsk->stack = stack;
+	*(struct task_struct **)tsk->stack = tsk;
+	initialize_thread_info(orig, tsk);
+	get_thread_info(tsk)->task = tsk;
 
 	/* One for us, one for whoever does the "release_task()" (usually parent) */
 	atomic_set(&tsk->usage,2);
@@ -921,7 +922,7 @@
 	if (nr_threads >= max_threads)
 		goto bad_fork_cleanup_count;
 
-	if (!try_module_get(p->thread_info->exec_domain->module))
+	if (!try_module_get(get_thread_info(p)->exec_domain->module))
 		goto bad_fork_cleanup_count;
 
 	if (p->binfmt && !try_module_get(p->binfmt->module))
@@ -1131,7 +1132,7 @@
 	if (p->binfmt)
 		module_put(p->binfmt->module);
 bad_fork_cleanup_put_domain:
-	module_put(p->thread_info->exec_domain->module);
+	module_put(get_thread_info(p)->exec_domain->module);
 bad_fork_cleanup_count:
 	put_group_info(p->group_info);
 	atomic_dec(&p->user->processes);
diff -Naur linux-2.6.8.1/kernel/sched.c linux-2.6.8.1-m68k-20040817/kernel/sched.c
--- linux-2.6.8.1/kernel/sched.c	2004-08-14 20:55:59.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/kernel/sched.c	2004-08-16 01:24:47.000000000 +1000
@@ -3212,10 +3212,10 @@
 #endif
 #ifdef CONFIG_DEBUG_STACK_USAGE
 	{
-		unsigned long * n = (unsigned long *) (p->thread_info+1);
+		unsigned long * n = (unsigned long *) (get_thread_info(p)+1);
 		while (!*n)
 			n++;
-		free = (unsigned long) n - (unsigned long)(p->thread_info+1);
+		free = (unsigned long) n - (unsigned long)(get_thread_info(p)+1);
 	}
 #endif
 	printk("%5lu %5d %6d ", free, p->pid, p->parent->pid);
@@ -3286,9 +3286,9 @@
 
 	/* Set the preempt count _outside_ the spinlocks! */
 #ifdef CONFIG_PREEMPT
-	idle->thread_info->preempt_count = (idle->lock_depth >= 0);
+	get_thread_info(idle)->preempt_count = (idle->lock_depth >= 0);
 #else
-	idle->thread_info->preempt_count = 0;
+	get_thread_info(idle)->preempt_count = 0;
 #endif
 }
 
diff -Naur linux-2.6.8.1/mm/bootmem.c linux-2.6.8.1-m68k-20040817/mm/bootmem.c
--- linux-2.6.8.1/mm/bootmem.c	2004-08-14 20:55:10.000000000 +1000
+++ linux-2.6.8.1-m68k-20040817/mm/bootmem.c	2004-08-16 01:24:48.000000000 +1000
@@ -269,19 +269,20 @@
 	map = bdata->node_bootmem_map;
 	for (i = 0; i < idx; ) {
 		unsigned long v = ~map[i / BITS_PER_LONG];
-		if (v) {
-			unsigned long m;
-			for (m = 1; m && i < idx; m<<=1, page++, i++) {
-				if (v & m) {
-					count++;
-					ClearPageReserved(page);
-					set_page_count(page, 1);
-					__free_page(page);
-				}
-			}
-		} else {
+		unsigned long m;
+		if (!v) {
 			i+=BITS_PER_LONG;
-			page += BITS_PER_LONG;
+			continue;
+		}
+		for (m = 1; m && i < idx; m<<=1, i++) {
+			if (!(v & m))
+				continue;
+			page = virt_to_page(phys_to_virt((i << PAGE_SHIFT) +
+							 bdata->node_boot_start));
+			count++;
+			ClearPageReserved(page);
+			set_page_count(page, 1);
+			__free_page(page);
 		}
 	}
 	total += count;

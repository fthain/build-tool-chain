diff -uNr glibc-2.3.3-lfs-5.1-ORIG/sysdeps/unix/sysv/linux/m68k/fcntl.c glibc-2.3.3-lfs-5.1/sysdeps/unix/sysv/linux/m68k/fcntl.c
--- glibc-2.3.3-lfs-5.1-ORIG/sysdeps/unix/sysv/linux/m68k/fcntl.c	2000-10-15 04:48:52.000000000 +1100
+++ glibc-2.3.3-lfs-5.1/sysdeps/unix/sysv/linux/m68k/fcntl.c	2004-05-22 16:45:59.000000000 +1000
@@ -1 +1,140 @@
-#include <sysdeps/unix/sysv/linux/i386/fcntl.c>
+/* Copyright (C) 2000, 2002, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <assert.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <stdarg.h>
+
+#include <sysdep-cancel.h>
+#include <sys/syscall.h>
+#include "../kernel-features.h"
+
+/* This variable is shared with all files that check for fcntl64.  */
+int __have_no_fcntl64;
+
+
+int
+__fcntl_nocancel (int fd, int cmd, ...)
+{
+  va_list ap;
+  void *arg;
+
+  va_start (ap, cmd);
+  arg = va_arg (ap, void *);
+  va_end (ap);
+
+  switch (cmd)
+    {
+    case F_GETLK64:
+      /* Convert arg from flock64 to flock and back.  */
+      {
+	struct flock fl;
+	struct flock64 *fl64 = arg;
+	int res;
+
+	fl.l_start = (off_t)fl64->l_start;
+	/* Check if we can represent the values with the smaller type.  */
+	if ((off64_t) fl.l_start != fl64->l_start)
+	  {
+	    __set_errno (EOVERFLOW);
+	    return -1;
+	  }
+	fl.l_len = (off_t) fl64->l_len;
+	/* Check if we can represent the values with the smaller type.  */
+	if ((off64_t) fl.l_len != fl64->l_len)
+	  {
+	    __set_errno (EOVERFLOW);
+	    return -1;
+	  }
+	fl.l_type = fl64->l_type;
+	fl.l_whence = fl64->l_whence;
+	fl.l_pid = fl64->l_pid;
+
+	res = INLINE_SYSCALL (fcntl, 3, fd, F_GETLK, &fl);
+	if (res  != 0)
+	  return res;
+	/* Everything ok, convert back.  */
+	fl64->l_type = fl.l_type;
+	fl64->l_whence = fl.l_whence;
+	fl64->l_start = fl.l_start;
+	fl64->l_len = fl.l_len;
+	fl64->l_pid = fl.l_pid;
+
+	return 0;
+      }
+    case F_SETLK64:
+    case F_SETLKW64:
+      /* Try to convert arg from flock64 to flock.  */
+      {
+	struct flock fl;
+	struct flock64 *fl64 = arg;
+
+	fl.l_start = (off_t) fl64->l_start;
+	/* Check if we can represent the values with the smaller type.  */
+	if ((off64_t) fl.l_start != fl64->l_start)
+	  {
+	    __set_errno (EOVERFLOW);
+	    return -1;
+	  }
+	fl.l_len = (off_t)fl64->l_len;
+	/* Check if we can represent the values with the smaller type.  */
+	if ((off64_t) fl.l_len != fl64->l_len)
+	  {
+	    __set_errno (EOVERFLOW);
+	    return -1;
+	  }
+	fl.l_type = fl64->l_type;
+	fl.l_whence = fl64->l_whence;
+	fl.l_pid = fl64->l_pid;
+	assert (F_SETLK - F_SETLKW == F_SETLK64 - F_SETLKW64);
+	return INLINE_SYSCALL (fcntl, 3, fd, cmd + F_SETLK - F_SETLK64, &fl);
+      }
+    default:
+      return INLINE_SYSCALL (fcntl, 3, fd, cmd, arg);
+    }
+  return -1;
+}
+
+
+int
+__libc_fcntl (int fd, int cmd, ...)
+{
+  va_list ap;
+  void *arg;
+
+  va_start (ap, cmd);
+  arg = va_arg (ap, void *);
+  va_end (ap);
+
+  if (SINGLE_THREAD_P || (cmd != F_SETLKW && cmd != F_SETLKW64))
+    return __fcntl_nocancel (fd, cmd, arg);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  int result = __fcntl_nocancel (fd, cmd, arg);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+libc_hidden_def (__libc_fcntl)
+
+weak_alias (__libc_fcntl, __fcntl)
+libc_hidden_weak (__fcntl)
+weak_alias (__libc_fcntl, fcntl)
diff -uNr glibc-2.3.3-lfs-5.1-ORIG/sysdeps/unix/sysv/linux/m68k/lockf64.c glibc-2.3.3-lfs-5.1/sysdeps/unix/sysv/linux/m68k/lockf64.c
--- glibc-2.3.3-lfs-5.1-ORIG/sysdeps/unix/sysv/linux/m68k/lockf64.c	2000-10-15 04:49:26.000000000 +1100
+++ glibc-2.3.3-lfs-5.1/sysdeps/unix/sysv/linux/m68k/lockf64.c	2004-05-22 16:11:37.000000000 +1000
@@ -1 +1,84 @@
-#include <sysdeps/unix/sysv/linux/i386/lockf64.c>
+/* Copyright (C) 1994, 1996, 1997, 1998, 1999, 2000, 2003
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/types.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <string.h>
+#include <sysdep.h>
+
+#include "kernel-features.h"
+
+/* lockf is a simplified interface to fcntl's locking facilities.  */
+
+/* This variable is shared with all files that check for fcntl64. The
+   declaration is in fcntl.c.  */
+extern int __have_no_fcntl64;
+
+int
+lockf64 (int fd, int cmd, off64_t len64)
+{
+  struct flock fl;
+  off_t len = (off_t) len64;
+
+  memset ((char *) &fl, '\0', sizeof (fl));
+
+  /* lockf is always relative to the current file position.  */
+  fl.l_whence = SEEK_CUR;
+  fl.l_start = 0;
+  fl.l_len = len;
+
+  if (len64 != (off64_t) len)
+    {
+      /* We can't represent the length.  */
+      __set_errno (EOVERFLOW);
+      return -1;
+    }
+  switch (cmd)
+    {
+    case F_TEST:
+      /* Test the lock: return 0 if FD is unlocked or locked by this process;
+	 return -1, set errno to EACCES, if another process holds the lock.  */
+      fl.l_type = F_RDLCK;
+      if (__fcntl (fd, F_GETLK, &fl) < 0)
+	return -1;
+      if (fl.l_type == F_UNLCK || fl.l_pid == __getpid ())
+	return 0;
+      __set_errno (EACCES);
+      return -1;
+    case F_ULOCK:
+      fl.l_type = F_UNLCK;
+      cmd = F_SETLK;
+      break;
+    case F_LOCK:
+      fl.l_type = F_WRLCK;
+      cmd = F_SETLKW;
+      break;
+    case F_TLOCK:
+      fl.l_type = F_WRLCK;
+      cmd = F_SETLK;
+      break;
+
+    default:
+      __set_errno (EINVAL);
+      return -1;
+    }
+  return __fcntl (fd, cmd, &fl);
+}
